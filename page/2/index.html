<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="读书、写字、周游天下...">
<meta property="og:type" content="website">
<meta property="og:title" content="Joey  chang's  blog">
<meta property="og:url" content="http://ijoeychang.github.io/page/2/index.html">
<meta property="og:site_name" content="Joey  chang's  blog">
<meta property="og:description" content="读书、写字、周游天下...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joey  chang's  blog">
<meta name="twitter:description" content="读书、写字、周游天下...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Joey  chang's  blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7051b02e64de9396c8130272189f6a4d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Joey  chang's  blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/03/2017/读《浪潮之颠》/" itemprop="url">
                  读《浪潮之颠》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-12-03T00:00:00+08:00" content="2017-12-03">
              2017-12-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书心得/" itemprop="url" rel="index">
                    <span itemprop="name">读书心得</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/03/2017/读《浪潮之颠》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/03/2017/读《浪潮之颠》/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刚刚读完了浪潮之颠，有点相见恨晚的感觉。通读完它，花费了很多时间，可是还是很遗憾没有几年前就读到它。</p>
<p>第一次真正的知道吴军，还是大半年前在得到 app 开始听他的硅谷来信专栏。听了几集后，便被他的魅力深深吸引。现在，他的专栏已经听了近一年的，还会一直听下去，他的书，已经读完了三本，还会继续读下去。</p>
<p>以前听过很多音频，却从来没有听他的有感觉。人和人交往，有喜欢的，有不喜欢的，或许因为他的思维正和我的胃吧，他的很多见识让我钦佩，他的很多看法让我很认同。当然，就像你会不喜欢某个人一样，你可能未必会像我这样欣赏他。</p>
<p>读了他的数学之美，让我觉得，如果高中时候读到，可能我就不那样讨厌数学了。如果数学再好些，我的求学、工作轨迹都要被改变。现在会觉得，兴趣很重要，如果对某个方向感兴趣了，投入时间和精力，一般都会有不错的回报。以前不喜欢数学，是因为初中时不喜欢一个数学老师开始的。现在回想，一个好的老师对一个人的影响真的会很深远，同样，一个不好的老师也是一样。</p>
<p>读他的大学之路，不禁让我想起以前高中时，我会找一些介绍中国各个大学的小书偶尔读读，以此给自己激励。为了上个好大学，我会更努力学习。那年头，不知道大学之路这本书有没有出版，如果读了它，可能自己对自己的要求会更高一些。现在业余时间，我还是会花不少的时间学习英语，我就是希望不久的未来自己可以和老外毫无压力的沟通，我还想赚到美元。以后有孩子了，好好栽培他，争取让他能够走出国门，令他眼光不致于狭隘。</p>
<p>读浪潮之颠，除了对自己熟知的一线科技公司（比如苹果，微软，谷歌，Facebook等）有了更进一步了解，还认识了一些其它领域的巨头，比如基因科技、GE（爱迪生创办的公司）、红杉资本、AT&amp;T、3M等，这些公司以前自己根本不知道它们的存在，而它们却从不同角度深刻影响着这个世界。现在想来，读书少，势必会孤陋寡闻。</p>
<p>本书的一个章节介绍了 AT&amp;T 的百年兴衰史。使我知道它的贝尔实验室（Bell Laboratories）不仅在通信领域长期执牛耳，而且在射电天文学、晶体管和半导体、计算机科学等领域领先于世界。它发现了电子的波动性，发明了信息论，组织发射了第一个通信卫星。它不紧不慢地向上走了百年，才爬到顶点，可是走下坡路却只是短短的十年。这足以为戒。就像诺基亚从木工厂到手机之王，曾经被视为成功转型的典范，谁知没多少年之后曾经的 “大厦” 顷刻间便轰然倒塌。不能不让人惋惜。</p>
<p>这说明了一个道理，任何事物都有寿命，公司也一样，没有人能活两百岁，也没有公司可以辉煌两百年，这是规律，很难超越。科技的发展不是均匀的，而是以浪潮的形式出现。一家一家超级跨国公司，就像一波波浪潮，一浪赶一浪。对个人来讲，看清楚浪潮，赶上浪潮，便不枉此生。</p>
<p>自己一直不太了解金融，通过本书，知道了风投公司红杉资本和 KPCB，知道了次贷危机是如何造成经济危机的。金融，经济学很重要，任何专业的人都应该学习一些相关知识，只有那样，才能看清很多现象的本质。比如比尔盖茨等大佬们把钱全部捐出来成立基金，并不是单纯的完全为了无私奉献，很多人是为了避税。不过说实话，盖茨确实做了不少好事情。</p>
<p>通过读此书，还让我对办公司拉投资的流程有了了解。金融，经济，这些学科里面的学问大得很，很多道理你了解了，或者明白了，你的观念会被改变很多。起码我是这样的。</p>
<p>很多高科技公司，包括苹果，谷歌，Facebook，雅虎等，其背后竟然被华尔街等金融机构操控。</p>
<p>华尔街除了从科技公司上市和炒作科技公司股票上赚钱，它们还可以操作公司的并购和拆分。所以一家上司公司，如果融资方式和时机不合理，创始人的股份占比很有可能被幕后财团超过，那样创始人的决断权就被剥夺了。曾经作为互联网第一的雅虎就是这样被董事会给卖掉的。创始人杨振远虽然不乐意，却已无能为力。</p>
<p>一家国际大公司，若想不受华尔街影响，唯一方式就是不上市。</p>
<p>金融业在整个经济活动中起着血液的作用。健康的金融环境和秩序可以帮助科技公司的成长。但是由于金融业和巨大的利益联系在一起，因此贪婪、投机甚至非法的欺骗行为是金融业永远摆脱不了的阴影。</p>
<p>作为一名技术人员，吴军开发设计了谷歌中日韩文核心搜索算法，还曾任职过腾讯公司高级副总裁，可是他却不是给人呆板无趣的印象，除了科技，他还涉及到很多领域，包括文学、历史、投资、金融、教育、艺术、摄影等，而且在每个领域成绩都不错。明明是一名科技工作者，却写出好几本文科专业人士写不出的畅销书。不得不让人羡慕。</p>
<p>通过读吴军的书以及听他的专栏，大半年来，自己真觉得受益匪浅。</p>
<p>首先是找到了一个不错的自我管理方法，即OKR:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Google目标管理方法OKR(Objects Key Results)</span><br><span class="line">每个季度都需要给自己定一个或者几个目标（Objects）,以及衡量目标是否达成的关键结果（Key Results）。</span><br><span class="line">季度结束时，每个人都会给自己的目标完成情况打分。完成了，得分是1。部分完成，得分是0到1之间的数字。</span><br><span class="line">目标要有挑战性，得分总是1，并不能说明工作好，而是目标定得太低。</span><br><span class="line">总结季度工作时，可以增加当初没有制定的目标，对于不打算完成的目标，或者已经过时、不再有意义的目标，不能删除，但是可以说明为什么没有做。）</span><br></pre></td></tr></table></figure>
<p>现在我一直在用它做季度管理，包括工作、学习、读书规划方面，已经使用半年，效果很不错。</p>
<p>再有，就是学习他的思维，学习他思考问题的方式，模仿他的文笔，学习他组织语言的能力。只文科好不行，只理科好也不行，只有文理科都好了，才会胜过很多人。文理相辅相成，文科突出人文，理科辅之于科技，站在人文与科技的交叉口，才能立于不败之地，才能创造伟大。</p>
<p>学好理科，学好逻辑，可以达到奇妙的效果，即使不是预言家，却可以通过逻辑推理来推断未来。早在2011年出版《浪潮之巅》的时候，吴军就说未来无现金支付会很普遍，看看现在，大街小巷，支付宝支付、微信支付已经渗入到人们的各个方面。</p>
<p>学好文科，善于表达自己的思想。有好的文笔和分享方式，可以让人很快积累大量财富。看看现在得到、知乎上面的大佬是如何赚钱的就知道了。吴军、李笑来等，通过写作，一年就至少可以赚几千万。</p>
<p>学习也是有方法的，每个人的一生都是学习的一生。很多大牛之所以为大牛，就是因为他们的学习能力很强，而且还在一直学习。吴军成绩已经很高了，却还在一直学习中。他说，“人的商业知识和眼光不是天生的，需要不断地、有心地学习。要系统的了解商业，就需要有专业的老师。了解商业的规律，让一生的时间投资有效。时间是最大的财富，要投入到最有意义，最有影响的地方去。” </p>
<p>学习商业知识是这样，学习其它科目，何尝不是呢？在自己的行业找到顶级大牛，向他们学习，向他们看齐，或许这是最快最有效的学习方法。</p>
<p>关于如何写作，吴军博士说，“写作要关注内容，用朴实的文风表达自己的体会。训练讲话和写作的逻辑性，比如如何立论，并用论据支持论点。公众场合讲话，不多说哪怕一句废话，也不落掉任何一句关键的话。想写得好，首先要说得清楚，然后，再用大家喜欢的语言，把要说的话描述出来，就形成了好的作品。” </p>
<p>所以，有内容才是写作的最佳方式，而不是有华丽的辞藻却没有很好的立意。</p>
<p>总之，《浪潮之巅》是一本极好的书，是值得认真研读的书。愿还没读过此书的朋友都去读一读，相信一定会让你长知识的。</p>
<p>2017.12.03  夜<br>上海 杨思地铁站</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/17/2017/读《傅雷家书》/" itemprop="url">
                  读《傅雷家书》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-17T21:12:00+08:00" content="2017-11-17">
              2017-11-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书心得/" itemprop="url" rel="index">
                    <span itemprop="name">读书心得</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/17/2017/读《傅雷家书》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/17/2017/读《傅雷家书》/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>早听说过这本书，只是直到最近才把它读完。读后，对傅老先生的崇敬之情一直不去。现在觉得做文化研究的人，都应该学习那个年代老一辈学者的为学态度。</p>
<p>本着做笔记是对一本好书最大的敬意，这里简单写下我的阅后感受。</p>
<p>第一次被傅雷的文字打动，是他的那句，“赤子是不知道孤独的，赤子孤独了，会创造一个世界”。当时读到这句，有莫名的感动，有深深的回味。</p>
<blockquote>
<p>赤子之心这句话，我也一直记住的。赤子便是不知道孤独的。赤子孤独了，会创造一个世界，创造许多心灵的朋友！永远保持赤子之心，到老也不会落伍，永远能够与普天下的赤子之心相接相契相抱！你那位朋友说得不错，艺术表现的动人，一定是从心灵的纯洁来的！不是纯洁到像明镜一般，怎能体会到前人的心灵？怎能打动听众的心灵？</p>
</blockquote>
<p>以前一直觉得最经典的一定是文言文，一直错误的认为只有古老的才是好的，现在却觉得白话文也可以是经典，甚至是经典中的极品。《傅雷家书》，给我就有这种感觉。这本书，应该是最近几年我读过的自认为最好的书了。</p>
<p>书中的文章主要是傅雷写给其子傅聪的信件，文中大多是比较好理解的日常白话文，没有学术范儿，可是里面却包含着很多人生哲学和道理，包括如何为人处世，包括如何做人如何做学问。那些道理，很值得我们每个人深思和借鉴。</p>
<p>该书信件写于五十年代，傅雷是那个时代极好的翻译家，一生翻译了多部世界名著，傅聪是国际上享有盛誉世界级的钢琴大家，1934 年生，现在八十多岁了。傅雷夫妇在 1966 年，文革开始的第一年，因不堪屈辱，双双自杀。傅聪一直在国外。</p>
<p>想想那个年代的背景和历史，真不希望这个国度会再次出现那个时代文人身上发生的事情。</p>
<p>傅雷教育傅聪要先做人，再做艺术。在为人处世上，要慎于许诺，要善于发现自己问题，分析问题，努力改正自己毛病。</p>
<p>他说，“有些脾气也许一辈子也改不了，但主观上改，总比听其自然或是放纵好，你说对吗？”</p>
<p>他教育傅聪如何做学问，如何做艺术，他说：</p>
<blockquote>
<p>艺术不但不能限于感性认识，还不能限于理性认识，必须要进行第三步的感情深入。换言之，艺术家最需要的，除了理智以外，还有一个爱字！所谓赤子之心，不但指纯洁无邪，指清新，而且还指爱！法文里有句话叫做“伟大的心”，意思就是“爱”。这“伟大的心”几个字，真有意义。而且这个爱绝不是庸俗的，婆婆妈妈的感情，而是热烈的、真诚的、洁白的、高尚的、如火如荼的、忘我的爱。</p>
<p>艺术品是用无数“有生命力”的部分，构成一个一个有生命的总体。一个人弄艺术非真实、忠诚不可。</p>
<p>中国哲学的理想，佛教的理想，都是要控制感情，而不是让感情控制。假如你能掀动听众的感情，使他们如醉如狂，哭笑无常，而你自己屹如泰山，像调度千军万马的大将军一样不动声色，那才是你最大的成功，才是到了艺术与人生的最高境界。</p>
<p>艺术是火，艺术家是不哭的。</p>
<p>凡是一天到晚闹技巧的，就是艺术工匠而不是艺术家。一个人跳不出这一关，一辈子也休想梦见艺术！艺术是目的，技巧是手段：老是只注意手段的人，必然会忘了他的目的。</p>
<p>为学最重要的是“通”，通才能不拘泥，不迂腐，不酸，不八股；“通”才能培养气节、胸襟、目光；“通”才能成为“大”，不大不博，便有坐井观天的危险。我始终认为弄学问也好，弄艺术也好，顶要紧的是humain（人）。要把一个人尽量发展，没成为某某某家以前，先要学做人;否则那种某某家无论如何高明也不能对人类有多大贡献。</p>
<p>我们学古典作品，当然不仅仅是为古典而古典，而尤其是为了整个人格的修养，尤其是为了感情太丰富的人的修养！</p>
</blockquote>
<p>傅聪也很配合，他没有让傅雷失望。他在国际上获得盛誉，让祖国为此骄傲。</p>
<p>傅聪有音乐天分，但是如果没有傅雷的教导，他应该达不到后来他达到的那种高度。傅聪也给他的外教名师说，他在东方还有个很好的指导老师（傅雷）。</p>
<p>我觉得，我可以通过阅读此书，学到一些为人处世的方法，可以学到一些正确的做学问，做艺术的态度。我一直觉得，文学、音乐、美术等都算作艺术，凡为同类的，都是有相通性的。为学，关键在态度。态度正，才能学得更深入，才能有更深造诣。</p>
<p>或许每一个想好好培养自己孩子的父母都应该认真读读这本书。该书出版三四十年来，在国内影响巨大。家书类，可与《曾国藩家书》相媲美。想想后者的名声和影响，其价值可见一斑了。</p>
<p>傅雷评价老舍，说，“我对老舍的早年作品看法已大大不同。从前觉得了不起的那篇《微神》，如今认为太雕琢，过分刻画，变得纤巧，反而贫弱了。一切艺术品都忌做作，最美的字句都要出自自然，好像天衣无缝，才经得起时间考验而能传世久远。比如 ‘山高月小，水落石出’ 不但写长江中赤壁的夜景，历历在目，而且也写尽了一切兼有幽远、崇高与寒意的夜景；同时两句话说得多么平易，真叫做’天籁’！”</p>
<p>他这样评价，让我觉得权威是不能盲目迷信的，读者应该有自己的思考和认知，不能名家说什么就是什么，要有怀疑精神，尽信书不如无书。对待老舍是这样，对待一切学问家都应该是这样。对待他人是这样，对待自己也是，做学问一定要严谨。</p>
<p>因为傅聪和傅雷都是为了学问为了艺术而不顾劳累不顾身体的工作狂，傅雷就告诫傅聪，工作之余，应该学会适时的休息。只有有好的心情和健康的身体，才能更好的做学问做艺术。他说:</p>
<blockquote>
<p>“ ‘寒波淡淡起，白鸟悠悠下’，自然界的良辰美景岂不成年累月摆在人面前，人如何不消沉至于不可救药的呢？相反，我认为生活越紧张越需要这一类的调剂，多亲近大自然倒是维持身心平衡的最好的办法。”</p>
</blockquote>
<p>想想自己的现况，工作上会觉得有不舒服的地方，加之前段时间做了个手术，深刻体味到了健康的重要性，更想可以合理的作息，以此修行健康的身心。有时真的很想多出去走一走，看一看。每每想到 “ 每逢春秋佳日，徜徉于山巅水涯 ”，就觉得不亦乐哉！而意义不大的加班，真的不是我想要的。</p>
<p>读此书，我发现自己也是那样的人 – “虽然性格随和，性情和蔼，可是骨子里是个原则坚定、性格坚强的人。”</p>
<p>或许，最近一段时间我应该好好捋一捋思路，人生路上总会有许多岔路口，我又到了要选择方向的地方了。</p>
<pre><code>2017.11.17 21:12 
  上海 新泾北苑
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/2017/那天，我做了个小手术/" itemprop="url">
                  那天，我做了个小手术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-12T00:00:00+08:00" content="2017-11-12">
              2017-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/我的随笔/" itemprop="url" rel="index">
                    <span itemprop="name">我的随笔</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/12/2017/那天，我做了个小手术/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/12/2017/那天，我做了个小手术/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天，拆掉了左手腕上的手术缝合线，现在还有很明显的疤痕，希望过段时间可以去除掉。﻿﻿</p>
<p>本来想说这是我人生第一次做手术，但是仔细想想，应该不是第一次，在我很小很小还不记事的时候，有次被马车轧到了腿，那次运气还好，没有被牲畜踩到，不然可能早在那个时候这个世界上就没有我了。现在我的脑海仅存的那时候的一点点记忆，就是在医院里看着很粗的针头后大哭着喊奶奶。那次手术的疼痛，现在已经记不得了，可是这次手术的痛，却是实实在在很清晰的。﻿</p>
<p>大概十几年之前，就发现自己左手腕处有个小疙瘩，有时大，有时小，大时有黄豆那么大，阴天下雨时候还会疼，曾经问过老家门口的大夫那是什么，他不怎么在意的说，可以割掉的。﻿</p>
<p>因为以前穷，有点不舍得花几千块钱看它，就一直没睬它，觉得应该无大碍的。转眼这么多年过去了，自己对看病花费不再以前那样看重，去岁我去医院拍了片，医生说，那是腱鞘囊肿。当时他给开了点止疼药，但是说，敷药治标不治本，要想治本，需要动手术把囊肿切除。﻿</p>
<p>因为工作上要天天敲打键盘，也因为没有太多时间，然后我又拖了一年没睬它。﻿</p>
<p>国庆假期前，我突然心血来潮，心想应该趁假期做个小手术，不然一直拖着也不是个事。﻿</p>
<p>假期前两天去医院，发现人好多，一直预约到了节后两周才能做手术。﻿</p>
<p>那天周五，请了一天假，本来工作日不上班应该感觉不错的，可是因为是去医院，却感觉有点沉重。医院，让我觉得是人与疾病，与生老病死做斗争的地方，特别看到很多老人躺在病床上不能自由行动的时候，不由得想到人面对生老病死时的无力。﻿</p>
<p>当我在病房等待的时候，我看到护士桌旁那里写有肿瘤科，我还以为他们搞错了，我的怎么会是肿瘤科呢！早上九点多，一个大夫过来和我们等待做手术的病友一一谈话。到我的时候，他把我喊到了房间内一个小屋子里说了一些注意事项。他说即使做手术了，也会有一定的概率会复发，而且术后，他们要对切下的囊块儿做检查，他说如果有恶性性质会在一周内通知我，如果没有事就不电话通知了。那一刻，我内心崩得很紧。没想到我也会有肿瘤。心想千万不要给我打电话啊！﻿</p>
<p>手术在十二点左右进行。我进了手术室，躺在手术台，那个地方以前只有在电视里看到过，这次我却体验了。医生在我左手腕用很粗的针管打了四针，向里面注射了麻药。﻿</p>
<p>大概十分钟，就感觉左手有肿胀，麻麻的感觉。手术时，我想看过程，然而医生们不让，他们让我把头扭向另一边，然后把我左半身用布盖了起来，然后一位医生按着我的左手，一位医生进行手术。﻿</p>
<p>他们在手术的过程中还在聊天，我听了一点，大概是聊他们前辈或者领导做学术造假的事情。﻿</p>
<p>手术开始不疼，可是随着医生说我这个囊块儿比较深，长到了骨头边，然后问我疼不疼，我说有点，他说那就忍忍吧，用不了多大会就好了。﻿</p>
<p>然后我就能感觉到刀片在我骨头边切肉，那种疼痛，让我紧紧攥着右拳头，不大功夫，病号服就被我的汗浸湿了。钻心的半小时，应该是我体验过的第二痛。不知道如果没有麻药会是怎样的感觉。﻿</p>
<p>术后，过了忐忑的两周，还好，没有收到医院的电话。我想，我这个应该不会再复发了吧。走下手术台时，医生也说我这个应该不会复发了。﻿</p>
<p>通过这件事，我更加认识到了健康的身体有多么重要。平常再忙，也不能忽视了锻炼身体。﻿</p>
<p>不要等疾病来了，才想到要锻炼身体吧。无论做什么行业的工作，健康永远是最重要的。﻿</p>
<p>2017.11.12 下午<br>上海 新泾北苑</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/04/2017/读《美的沉思》/" itemprop="url">
                  读《美的沉思》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-04T00:00:00+08:00" content="2017-11-04">
              2017-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书心得/" itemprop="url" rel="index">
                    <span itemprop="name">读书心得</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/04/2017/读《美的沉思》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/04/2017/读《美的沉思》/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不久前读完了《美的沉思》，被蒋勋的文笔给吸引了。读他的书，像是在享受。以后会找时间再读他其它的书。</p>
<p>越来越觉得时间过得快，快节奏的工作，快节奏的学习，很多时候会让人觉得时间是以周为单位消失的，往往这周末做了点事，很快到了下一个周末，回忆一下，会被吓一跳，“妈呀，上周末做的事情，怎么感觉刚刚经历过！”</p>
<p>时间过得快，特别是当人面对电脑的时候，工作中，解决了一两个问题，可能一天就没了，有时还会到深夜。长时间这样，真的有感觉自己的生命被缩短。</p>
<p>几个月前，我发现一个问题，就是晚上下班回到住处后，再打开电脑处理事情，能做的事情很少，做事效率极低，一不小心，可能就到了深夜，有点兴奋的大脑，这个时候也不容易能尽快睡下，那样导致晚睡不足再导致第二天精力不佳，如此恶性循环。</p>
<p>因为不想一直被电脑奴役，现在的我，晚上很少在住处打开电脑了，也很少看电影电视，固定时间段，更强制自己远离一切电子产品。空出来的时间，我会用来读书，一般读纸质书。我觉得我应该加大读书力度，多读书，读好书，然后写读书笔记。</p>
<p>这是一个远离尘嚣的方式，一切返璞归真，一切归于平静。让人内心安静随和，是很多人想要的状态，而蒋勋就有这种能力。读蒋勋的书，听蒋勋的音频，可以让人平静。</p>
<p>很早就买了《美的沉思》这本书，可惜一直没有读完，直到最近半年开始制定严格的读书计划，才认真读了这本书。现在觉得，一个好的读书计划，加上严格的执行步骤，是很必要的。</p>
<p>这本书，就中西方的美学，包括雕刻、石窟、绘画、书法、诗歌等，做了以时间为顺序的介绍，书中有很多优美而又深刻的语句，让人读了有像逛博物馆般享受，仿若美人向你缓缓走来，是入门美学的不错教程。</p>
<p>山河湖海春夏秋冬风花雪月醉生梦死衣食住行，均可入画，入诗，入雕，入刻。伟大的艺术家们的作品可以给人以震撼地视听享受。</p>
<p>上言加餐饭，下言长相忆，“汉代的美，正是美在这日日月月的人情之常。在平凡到不能再平凡的一碗白饭中寄托着对生活的爱和肯定。”</p>
<p>魏晋风骨：<br>“魏晋的名士风流，不是轻薄的佯狂，而是从生命底层呼叫的痛贯心肝的哀号。<br>在弥漫着政治诬陷、战乱、道德虚伪的人世唱出了他们不屑、激奋的高亢之音。”</p>
<p>南北朝石雕：<br>五胡乱华三百年，华夏民族遭受了前所未有的屈辱，“身体可以受苦役，精神可以被屈辱，但是，那藏在内里的对生命真挚的爱仍使他们造出的佛像脸上有了笑容。让我们知道无论是什么阻难，生命都要往光明、善良、美好的世界升去。那些驮负着沉苦发愿的佛像，一尊一尊被竖立在中国的大地之上，仿佛是苦难中万民的发愿。”</p>
<p>就像龙门牛橛造像背后所刻铭记那样：</p>
<p>“若存拖生，生于天上诸佛之所。<br>若生世界，妙乐自在之处。<br>若有苦累，即令解脱。”</p>
<p>艺术史带给我们的不仅仅是那些有关艺术的知识，更重要的其实是这种分析能力。还有艺术能使人宽心，心烦的时候，听一听音乐，看一看名画，练一练书法，人会好受很多。</p>
<p>绘画的艺术，一画一世界，可以让人陷入沉思。尤其中国的泼墨山水画，那一幅幅山川，那一面面湖水，那一个个画中人物，就像一个个传说，一个个故事，让人留恋，让人回味。时间永远流动，绘画却可以定格在历史的某个页面。站在那个页面前的后人，可以遥想当年的前人，可以独与天地精神往来洪荒到劫毁。</p>
<p>一幅名画，可以价值连城。富春山居图，让我很想去台北故宫博物院，很想去看看真品的样子。</p>
<p>今天特意来上海博物馆看书画，出发的有点晚了，到博物馆排了半小时队，进到里面已经下午三点半。我看门前介绍，知道五点闭关，那样的话，时间根本不够用，所以一进里面，我就直接去三楼看书画。心想如果时间允许，还可以去四楼看下玉石。</p>
<p>没想到，在三楼，我两个展览室没看完就被管理人员吆喝着说要闭关了。</p>
<p>书法馆，一个个大师的真品面前，让人走不动脚步。其中看到赵孟頫的一幅足有好几米长的书法真品，真想能够穿过玻璃拿到那纸张，触摸一下，嗅一嗅。</p>
<p>中国书画的美，即使留白也散发着诗意的弥漫，绝美风景上面的隽秀字迹，嫣然摇动，冷香飞上诗句。</p>
<p>记得在苏州博物馆看明清大师们的画，一位妈妈教育四五岁的孩子：“你看他们画得多好，你要努力，以后也画出那样的画好不好？”<br>记得在徐州博物馆第一次看到金缕玉衣，看到古代帝王即使死后也要享尽荣华，自己深为感慨，深为震撼。</p>
<p>读《美的沉思》，享受的过程中，学到了一些书画常识。即使现在，台湾依然多大师，大师们的作品，是值得怀着崇敬之心去阅读的。</p>
<p>2017.11.04 下午<br>上海博物馆门前</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/2017/香港两日/" itemprop="url">
                  香港两日
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-29T22:40:00+08:00" content="2017-10-29">
              2017-10-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/周游天下/" itemprop="url" rel="index">
                    <span itemprop="name">周游天下</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/29/2017/香港两日/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/29/2017/香港两日/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周末去了趟香港。</p>
<p>去年十二月份的时候，去了趟深圳，和大学室友在深圳转了两天，其中第二天去了红树林风景区，那里和香港隔河相望，当时因为还没有办通行证，眼看着香港就那么近了却不能过去，那种感觉甚是难受啊。</p>
<p>今年上半年，我就早早的办了个护照和通行证，打算今年一定要到香江（香港）转一转的。</p>
<p>原本计划国庆节之前要做个小手术，把左手腕处已经存在多年的腱鞘囊肿切除，然后趁着假期好好养养伤口，然而因为医院就医的人实在多，我提前两天去，手术竟然一直预约到节后两周的日子才做。上周五刚做完手术，也没挡得住我要去香港，周六一早（早上五点）我就向机场赶去。好多年不习惯早起了，那天早起，早上感觉很困，很难受，可是一想到这是要去香港，要去我打小就向往的地方，我还是挺兴奋的。</p>
<p>一切都很顺利，飞机没有延误，还提前半小时到达了深圳。我要在深圳和同学先集合，然后再一起出关入港。</p>
<p>到了深圳，和张华、刘岩、马雷在福田口岸集合。人到齐的时候，差不多十点。</p>
<p>出入海关，需要两步，进出香港，先要一边海关放行，然后再要另一边海关准入。想想香港都回归二十年了，往返竟然还这么麻烦。</p>
<p>在海关还有个小插曲，我们一行四人差点走丢。因为香港那边还是比较国际化的，中国移动和中国联通，如果不办理特别套餐，在香港那边不能使用。</p>
<p>因为张华和我是第一次进入香港，虽然我们的通行证是磁卡，但是仍然需要走人工柜台，马雷用的是本本儿通行证，需要人工审核。开始我们不知道，于是马雷去人工审核那边排队了，我们三人走自动刷卡通道，刘岩顺利通行，可是我和华子被卡着了。我和华子无奈，只好去走人工审核通道，因为跟着人群和路标指示，又没有走马雷走的那一边，我们被指引到地下一层了。再出来的时候，发现手机都没信号了。当时有点小慌张，心想可别人再走丢了啊。</p>
<p>好在马雷他们两个先到，然后就一直在二楼电梯入口处那里等待，我们终于再次集合完毕。</p>
<p>这里说一下，海关审核的时候，香港那边的工作人员，虽然同样说的是粤语，却给人感觉怪怪的，不像深圳那边那样本土，香港的粤语，有点像电影里演员们说普通话带着浓重口音的那种感觉。不得不说，有些香港人对大陆人不是很友好，从他们说话语气和态度中可以知道。</p>
<p>进了海关，先要用港币（在深圳出关时兑换的，0.85 元兑换 1 港币）购买香港地铁票。票有一日通、八达通和单程票几种。如果只在香港待一天，然后想多逛些地方的话，一日通最实惠，100 港币一天，地铁差不多可以任意坐，不过只能两次往返海关。八达通可以自由充值，适合长期使用。单程票，则和其它地方的地铁单程票一样了。</p>
<p>坐上地铁，里面人还是蛮挤的，竟然没座儿，地铁第一站就坐得满满的，从第一站上车的，应该大部分都是大陆这边去旅游的。</p>
<p>香港的地铁，给人感觉很有古风，里面广告很像日本广告，风格和上海深圳这边完全不一样的，再有感觉就是破，包括香港地铁，还有香港的大楼，给人的感觉都是破旧，我想这应该是它们发展得早，存在的时间太长了吧。</p>
<p>我们第一站要去逛逛香港的闹市，然后去历史博物馆。</p>
<p>在香港的主要步行街走的时候，感觉他们的路很窄，有的地方，单行道仅仅能容得下一人行走，他们的大街也很窄，我们讨论，可能放在几十上百年前，那样的路已经很宽了，可是放在现在，他们显得很狭窄很拥挤，路上来来往往的车辆，会经常堵车。</p>
<p>再有就是，香港是靠左行走的，无论车辆还是行人，都是靠左走。刚开始我们很不适应，潜意识里都是靠右走，有时会和路人走个撞面，然后才意识到自己错了。不仅车道靠左，车辆内部的驾驶座儿也是不同于大陆的车辆的，他们的驾驶座位在右边。</p>
<p>中午在一条卖衣服的小街边的餐馆吃了碗面，小餐馆的老板一副爱答不理的样子，他竟然自始至终没有说一句话，一副冷冰冰的模样。不过面还算好吃，里面的肉给得很足，这点比大陆饭店做得好，我们这边碗里的肉都是肉沫，用筷子一搅就找不到了，他们那边却是实实在在的几大片肉。</p>
<p>香港那边消费很高，我吃的那碗面 36 港币一碗。在路边一家饭店门前看到一则招聘广告，洗碗工月工资一万三，想想自己的收入，我们不禁感慨，“ x , 我们来这里洗碗吧！”</p>
<p>下午我们在历史博物馆转了好几个小时。历史博物馆，里面倒没多少吸引人的真迹，不过在那里看了些纪录片和化石，才知道原来香港有人类的历史已经很久很久了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-41a5327a125ddc5b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港博物馆"></p>
<p>香港那边，国际化的味道很浓。在博物馆里面，好多参观者是老外。在馆里听着一个导游用不算特别流利的英语向六七个老外一处处的做讲解，在林则徐销烟展览处，听着那段让国人不堪回首的历史，不知道老外们做何感受。</p>
<p>我喜欢漫步在历史长河的画卷中，我喜欢在那样的氛围里任思绪遐想。悠悠岁月，茫茫大海，遥遥数千年，如果我活在古代，我会是什么身份呢？</p>
<p>我背着肩包行走在展览香港民俗的场景中，一个弯腰，肩包边斜插着的矿泉水掉在了地下，我还没来得及弯腰去拾，不远处一个胖胖的外国女士跑来弯腰拾起那瓶水，然后递给了我。我有点意外，然后冲她大声说了句，“ Thank you… ” 她冲我笑笑，没有说话，有点羞涩得走开了。</p>
<p>香港是很国际化的，到处是外国人，即使你旁边站着一个和你一样黄皮肤黑眼睛的人，他也很有可能来自南亚、东南亚、日本等国。在地铁里，旁边坐了个哥们，看他在认真看一本小书，我瞥了一眼，竟然是日文书。那哥们儿很有可能是日本人啊，谁知道呢，反正看不出来。我去化妆品店里，去零食店里，有服务员都用日语冲我招呼。他们可能认为我是日本人吧，当然我听不懂日文，也没有理她们。</p>
<p>在博物馆，因为一人漫步在想象里，我比他们几个走得慢。走着走着，几个人就走散了。等我觉得差不多可以出馆了，却发现找不到他们人了。我一个人去博物馆出口处等他们，等了三四十分钟，仍然不见人，我想他们不至于把我丢下先走吧。因为人生地不熟的，又因为电话打不通，时间长了，看着天慢慢就要黑，真有点着急，最后还是我等不下去了，我又进去博物馆重新走了一遍，最后在二楼电梯那边遇到刘岩。看到他第一眼，他就说已经在那里等我很久了。我也说在下面等他们很久了。后来找到马雷他们，我说，“我一直在下面出口的地方等你们，等了有四十分钟了，想着你们肯定还在博物馆里，然后我就坐在出口处等，我要守株待兔。” 刘岩说，“开始你在我们后面，我们在那里等你，也是守株待兔…” 听得出他有点不喜欢守株待兔这个词，我哈哈大笑…</p>
<p>出了博物馆，我们一行顺着路直走，要去维多利亚港了。</p>
<p>本来我想先看看星光大道，想和李小龙合影留念的，想当年，在我最难熬的日子里，李小龙精神给了我很大支撑，就是喜欢他那种精神，他的四部半电影，我曾看了多遍，还看过他的传记电视剧，感觉李真伟大啊，可惜天妒英才，让他早早过世，不然香港电影应该还会多出很多经典电影来。</p>
<p>那天很不巧，因为在修路，星光大道景点过不去。实在太遗憾了。</p>
<p>已经到了港口，海边的风景真的好棒，有点像上海的外滩，可是那河那江比黄浦江宽多了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-4ecc97e9b5612a20.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港留念"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-14e57204276dcf4e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维多利亚港"></p>
<p>港口那边很好看，人也很多，人来人往中，我听到有人在唱三毛的歌，“不要问我从哪里来… ” 我看了看他们，只见中间一位女士在高歌，旁边有两位中年男子在吹着不同的乐器在伴奏，他们在卖艺。</p>
<p>让人意外的是，他们旁边还有一个老外坐在地上玩弄着两个铁球，他在耍杂技，他在乞讨。老外也有穷人，也有乞丐。想想国内老外的身份地位一般较高，在香港看到他们乞讨，真有些意外了。</p>
<p>让人更意外的是，那里还有人在光明正大的宣传法轮功，看我们走近，她还向我们发传单，当然我们都没有接受。香港果然是很开放的地方，这在国内，是万万不被允许的。</p>
<p>坐船穿过维多利亚港，大概十五分钟的样子，船票只要 3块7港币，非常实惠。在自动购票机排队购票的时候，因为第一次用，还不怎么会玩儿，我们在那观看了好一会儿，这时来了几个老外，他们也要买票，其中一人对我说了句什么，我没听懂，然后我让他们先买了，买前买后，他都说了谢谢。在那里，英语不好真为难啊，想着在国外应该更甚。这次去香港，应该可以算为以后出国旅游先铺垫一下。在海外，不是你好不好意思说英语的问题，有时是你必须说啊！这再次坚定我要拿下英语听说能力的态度，我想赚老外的钱，想赚  dollar。</p>
<p>到了港口对岸，走不远就是香港有名的两家苹果商店其中之一了。我们去那里观看，三层楼都是苹果店，很豪华，人很多。我算了下，一个 iPhone 8 比内地可以便宜八百块。看着那么多喜欢的苹果产品，真想购买，想想还要存钱办正事，只好忍住了。心想以后要买了再过来吧。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-6183e09cc1e56f2c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apple store "></p>
<p>出了苹果商店，天色已然侵夕，华灯初上，灯火辉煌，我们沿路步行，想去香港回归纪念处看看。看着很近的距离，可是走了一会儿，发现那里还是很远，我们在水边休息了会儿，贪看了美丽的夜色，然后就准备归程了。那里草坪上有很多人在组建 party ,他们很多应该是印度人。几个人坐在地上围在一起或吃饭或聊天，应该是他们的风俗。在灯光辉煌的夜色里，坐在草坪上夜话，那样感觉应该不错的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-20bce92b4e99540b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港的夜"></p>
<p>回去的时候，在商店够买了些物品，然后就回深圳了。在香港的第一天就此结束。</p>
<p>第二天，这次和我一起去的是泉泉，第一天走了好多路，另外三人已经累坏了。</p>
<p>第二天一早，本着早去早回的想法，我们俩一早就从深圳出发到了香港。</p>
<p>这次来就没什么特意想逛的了，我说要不我们去香港大学转转吧，泉泉说好。</p>
<p>到了香港大学，让人有点失望，猛一看，那里哪像是大学！明明像商场和住宅区。可是那里却真真切切是享誉中外的港大。</p>
<p>大学综合排名，港大曾有全亚洲第二全港第一的名次，比北大清华还要靠前很多。国父宋中山，作家张爱玲，词人林夕，都是港大的校友。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-66db5fd3ec5d8229.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港大学"></p>
<p>香港作为一个弹丸之地，在经济，文化上能产出如此深远影响，我想应该和它的全球得天独厚的地理位置有关，加之被日本、英国统治过，英语作为港人的最重要语言之一，在学术上，他们可以和国际最前沿的科技无缝衔接，加上香港经济繁荣，作为全球顶级的金融中心，港大成绩突出就不足为怪了。</p>
<p>我和泉泉在港大溜达了好一会儿，因为校园在半山腰上，在教学楼里，你很难发现自己身处楼层第几层。</p>
<p>我们俩漫无目的的走，后来竟然到了学校后面的龙虎山。那里有稀稀疏疏的人在爬山，我俩顺着山路上行，想爬到顶层遥看不远处的维多利亚美景。可惜因为走了太多路实在累，也因为要赶着时间回深圳，我们竟然没有爬到山顶。爬有一半多点就原路返回了，甚为遗憾。</p>
<p>下山后，我们混作学生在学校餐厅吃了饭，吃的是咖喱牛肉饭，南方的饭让人吃不习惯，但那饭菜还可以，相对于学校外面，价格也实惠。</p>
<p>在港大，我才深深体会到什么是 “大学之大不在高楼而在大师”，我想此生自己与名校无缘，希望以后有孩子了可以培养他到海外学习。</p>
<p>吃过饭在路边休息的时候，有六七个年轻人走过来说想和我俩一起合个照。没搞明白怎么回事时我们就同意了。事后泉泉一直担心会不会是个什么骗局。我想他真是处事小心谨慎啊。那几个人应该是港大学生，他们中有两三个老外，其中一位妹子说是他们老师给他们布置的无聊作业。不知真假。</p>
<p>离开港大，我们一起出去逛，想买些化妆品和零食带回去。没想到在地铁里又遇见两件让我难忘的事。</p>
<p>其一是，某次进地铁，我俩刚下电梯，听到地铁门在嘟嘟，泉泉蹭的一下跑了进去，我没进去，地铁就关门了。好好不尴尬啊！地铁门关了，泉泉在里面比划着，我理解为他说我们下一站见。</p>
<p>再来地铁，我进去，到下一站，我下来了，可是一看车站里面没泉泉，还在担心是不是我理解错了，在车外我向后走了一车节，正好看到泉泉在门口，我又赶快跳进车里。泉泉说他上车看看我有没有理解错误。幸好找到人了，不大一会儿车就开了，一场虚惊。这有手机不能用，还真没安全感。</p>
<p>不过还好，有的商店里可以蹭 WiFi 。</p>
<p>再有一件，当我们坐车回深圳的时候，遇到了一位和蔼可亲、和颜善目的老太太。</p>
<p>开始源于在地铁里让座。我给老人让座，然后站在了她旁边，她也是刚被他人让座，然后说了好几声谢谢，她看到我左手腕包扎着，说，“小伙子，你看你的手都坏了还让座，来，你坐我这儿吧。”</p>
<p>我忙说，“不用，不用，我们马上就下车了，嘿嘿…”</p>
<p>老太太问，“你是哪里人啊？”</p>
<p>我答，“河南郑州”。我本来想说开封呢，怕她不知道，然后说了郑州。</p>
<p>她很高兴，“啊，原来是郑州的啊，我年轻的时候去过那里，那里交通很便利，铁路，公路，航空都很发达。”</p>
<p>我说是的。</p>
<p>她又问，“来香港几天了？”</p>
<p>我说，“两天，我们这正要回去呢。”</p>
<p>老太太说，“两天哪够啊，既然来了，还不多玩几天再走，香港有迪士尼，郑州没有，还有海洋公园，都很好玩的，应该去转转。”</p>
<p>我笑着说时间太赶了。</p>
<p>到了要换乘下车的地方，我们竟然在同一个站下车。虽然出了地铁走的路不一样，可是到了另外线路地铁，我们又碰面了。老太太看到我又聊了起来。</p>
<p>这次我知道，原来她要去墓地，她说，“我先生去世好多年了，我现在要去墓地祭拜他，今天我的孩子们也去。他们花了几十万买了一块儿墓地，两人墓位，等我老了也会去那里。我真是沾了我先生的光了。哎，其实人死后就那回事儿，骨灰洒在大海里也不错的。我今年 79 岁了，一个人住，不给孩子们找麻烦。”</p>
<p>我说，“这边消费水平真高啊。”</p>
<p>她说，“是的。越是内地来的，越觉得贵。特别房价贵，这是个世界性问题，哪里都一样的。这些年，大陆那边过来的人也多了。这里也经常过些国人节日，每年七月中，也过中元节，也是鬼节，很热闹了…”</p>
<p>看她那么大年纪了还一个人出门，我真有点心疼啊。</p>
<p>要进地铁的时候，老太太走得很快，边走边喊我们，“来，来，走这里…”</p>
<p>她一副轻车熟路的样子，走路很快，我们跟着她多走了两个入口才进地铁。</p>
<p>到了地铁里面，有位姑娘想给她让座，她挥挥手说，“不用不用，谢谢”。然后她站在一个门口，倚靠着座位边的铁架子继续和我们聊天。</p>
<p>她笑着说，“现在的孩子都挺有礼貌的。”</p>
<p>又说，“我年轻的时候当兵，五六年去过郑州，我有个表哥是郑州的，那时候他在国棉三厂上班。那是国企大厂，工人们都戴着个白帽子，看上去好像回民一样…”</p>
<p>她边说边笑着，眼睛眯着，很开心的样子。我忘了问了我当时的疑惑了。五十年代当兵，是国军呢？还是共军呢？如果是国军，那个时候怎么去大陆？如果是共军，后来怎么来了香港？</p>
<p>我说，“香港这边的福利应该挺好的。”</p>
<p>她说，“我们现在每个月都有补助，还是挺不错的，吃的，喝的，都挺好的。还有这边的小学生，补助都好几千呢，所以大陆那边有钱的都想法让孩子来这边上学。”</p>
<p>又随便聊了会。愉快的时间总是那么短暂，老太太要下车了。</p>
<p>临走，她拍了拍我的右胳膊，在地铁门口向我们挥手道别，她挥了挥手，又挥了一挥。地铁门关闭的那一刻，我知道此生我们再也不会再见了。我猜她也会这样想的吧。</p>
<p>回到深圳，时间尚早，我跟着泉泉去他们公司（招商银行）坐了会儿。他们公司刚开始使用不久的大楼，就在深交所旁边，非常气派。晚上几个人一起吃了个饭，为期两天的香港行就此结束了。</p>
<p>总体来说，香港给我的感觉很国际化。以前不出远门，总有井底之蛙之嫌，到了海外，才知道大千世界，他处别有洞天。</p>
<p>香港给我最大的想法是我要继续加大学习英语的力度，再有，以后有孩子了，得努力创造条件让他可以走出去学习、生活。现代人，需要有全球视野和国际化思维。</p>
<p>2017.10.29  22:40<br>上海 新泾北苑</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/24/2017/Firebase-教程--iOS-实时聊天/" itemprop="url">
                  Firebase-教程--iOS-实时聊天
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-24T00:00:00+08:00" content="2017-10-24">
              2017-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术博客翻译/" itemprop="url" rel="index">
                    <span itemprop="name">技术博客翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/24/2017/Firebase-教程--iOS-实时聊天/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/24/2017/Firebase-教程--iOS-实时聊天/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://www.raywenderlich.com/140836/firebase-tutorial-real-time-chat-2" target="_blank" rel="external">https://www.raywenderlich.com/140836/firebase-tutorial-real-time-chat-2</a></p>
<p>貌似市场上的主流 app 都有聊天功能，所以，我们的 app 也应当添加聊天功能啦。</p>
<p>然而，开发一个聊天工具是一个令人畏惧的工作。除了要有专门用于聊天的本地 UIKit 控件，我们还需要一个服务器来协调用户之间的消息和对话。</p>
<p>幸运的是，有一些不错的框架可以帮助我们：在<a href="https://www.firebase.google.com/" target="_blank" rel="external">Firebase</a> 的帮助下，我们可以不用写一行后端代码就可同步实时数据，而 <a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">JSQMessagesViewController</a> 则给我们提供了一个与原生消息 app 相似的消息传递 UI 。</p>
<p>在这篇 Firebase 教程中，我们将开发一个  <em>RIC</em> (Really Instant Chat) – 匿名聊天应用。如果你使用过 IRC 或者 Slack，这种 app 你应该很熟悉了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-c1fe919e57ee82fa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Real time chat app"></p>
<p>在此教程，您将学习到如下内容:</p>
<ol>
<li>使用 CocoaPods 设置 Firebase  SDK 和 JSQMessagesViewController。</li>
<li>使用 Firebase 数据库实时同步数据。</li>
<li>Firebase 匿名身份验证。</li>
<li>使用 JSQMessagesViewController 做为完整的聊天界面。</li>
<li>指示用户何时输入。</li>
<li>使用 Firebase 存储。</li>
</ol>
<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><p>下载初始工程  <a href="https://koenig-media.raywenderlich.com/uploads/2016/09/ChatChatFirebaseTutorial-start.zip" target="_blank" rel="external">the starter project here</a> 。现在，它包含一个简单的虚拟登录界面。</p>
<p>我们使用 CocoaPods 下载 Firebase SDK 和 JSQMessagesViewController。如果你还不会使用 CocoaPods ，请先学习我们这篇教程  <a href="http://www.raywenderlich.com/97014/use-cocoapods-with-swift" target="_blank" rel="external">Cocoapods with Swift tutorial</a>。</p>
<p>在项目目录下，进入终端，打开根目录下的 Podfile 文件，添加如下依赖代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Firebase/Storage&apos;</span><br><span class="line">pod &apos;Firebase/Auth&apos;</span><br><span class="line">pod &apos;Firebase/Database&apos;</span><br><span class="line">pod &apos;JSQMessagesViewController&apos;</span><br></pre></td></tr></table></figure>
<p>保存文件，命令行执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>完成依赖包下载后，在 Xcode 打开 ChatChat.xcworkspace 。在运行之前，先配置 Firebase 。</p>
<p>如果你从未使用过 Firebase，首先你需要创建一个账号。不用担心，这些是免费的。</p>
<blockquote>
<p><em>注:</em> Firebase 的操作细节，可以看这里 <a href="http://www.raywenderlich.com/109706/firebase-tutorial-getting-started" target="_blank" rel="external">Getting Started with Firebase tutorial</a>.</p>
</blockquote>
<p>#####创建 Firebase 账号 </p>
<p>登录  <a href="https://www.firebase.com/signup/" target="_blank" rel="external">the Firebase signup site</a>，创建账号，然后创建一个工程。</p>
<p>按照指示将 Firebase 添加到 iOS 应用程序，复制 <em>GoogleService-Info.plist</em> 配置文件到你的项目。它包含与应用程序的 Firebase 集成所需的配置信息。</p>
<p>build and run ，你将看到如下界面：</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/LoginScreen.jpg" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-8cddc149a138afb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Login Screen"></a></p>
<h5 id="允许匿名认证"><a href="#允许匿名认证" class="headerlink" title="允许匿名认证"></a>允许匿名认证</h5><p>Firebase允许用户通过电子邮件或社交帐户登录，但它也可以匿名地对用户进行身份验证，为用户提供唯一的标识符，而不需要了解他们任何信息。</p>
<p>要设置匿名验证，打开 Firebase 应用程序的 Dashboard，选择左侧的 Auth 选项，单击 “Sign-In” 方法，然后选择“ Anonymous”，打开 “ Enable” 按钮，然后单击 “Save”。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/EnableAnonAuth.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-787dde562d169a39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Enable anonymous auth"></a></p>
<p>像这样，我们启用了<em>超级秘密隐形模式</em> ! 好吧，虽然这只是匿名身份验证，但它仍然很酷。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/01/stealthmode.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-6da83ae75ea77c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Super secret stealth mode achieved"></a></p>
<h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><p>打开 LoginViewController.swift，添加 import UIKit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Firebase</span><br></pre></td></tr></table></figure>
<p>要登录聊天，app 需要使用 Firebase 身份验证服务进行身份验证。将以下代码添加到loginDidTouch(_:):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if nameField?.text != &quot;&quot; &#123; // 1</span><br><span class="line">  FIRAuth.auth()?.signInAnonymously(completion: &#123; (user, error) in // 2</span><br><span class="line">    if let err = error &#123; // 3</span><br><span class="line">      print(err.localizedDescription)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.performSegue(withIdentifier: &quot;LoginToChat&quot;, sender: nil) // 4</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释如下:</p>
<ol>
<li>首先，确保  name field 非空。<br>2.使用 Firebase Auth API 匿名登录，该方法带了一个方法块儿，方法块儿传递 user 和 error 信息。</li>
<li>在完成方法块里，检查是否有认证错误，如果有，终止运行。</li>
<li>最后，如果没有错误异常，进入 ChannelListViewController 页面。</li>
</ol>
<p>Build and run，输入你的名字，然后进入 app。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-a84208cd550291fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Empty channel list"></p>
<p>#####创建 Channels 列表</p>
<p>一旦用户登录了, app 导航到 ChannelListViewController 页面, 该页面展示给用户当前频道列表, 给他们提供选择创建新通道。该页面使用两个 section 的表视图。第一个 section 提供了一个表单，用户可以在其中创建一个新的通道，第二 section 列出所有已知通道。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-1f7b10766e2da484.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Channel list view"></p>
<p>本小节，我们将学到：</p>
<ol>
<li>保存数据到 Firebase 数据库</li>
<li>监听保存到数据库的新数据。</li>
</ol>
<p>在 ChannelListViewController.swift  的头部添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Firebase</span><br><span class="line"></span><br><span class="line">enum Section: Int &#123;</span><br><span class="line">  case createNewChannelSection = 0</span><br><span class="line">  case currentChannelsSection  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧随导入语句之后的 enum 中包含两个表视图 section 。</p>
<p>接下来，在类内，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Properties</span><br><span class="line">var senderDisplayName: String? // 1</span><br><span class="line">var newChannelTextField: UITextField? // 2</span><br><span class="line">private var channels: [Channel] = [] // 3</span><br></pre></td></tr></table></figure>
<p>注释如下 ：</p>
<ol>
<li>添加一个存储 sender name 的属性。</li>
<li>添加一个 text field ，稍后我们会使用它添加新的 Channels。</li>
<li>添加一个空的 Channel 对象数组，存储你的 channels。这是 starter 项目中提供的一个简单的模型类，它只包含一个名称和一个ID。</li>
</ol>
<p>接下来，我们需要设置 UITableView 来呈现新的通道和可用的通道列表。在 ChannelListViewController.swift 中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// MARK: UITableViewDataSource</span><br><span class="line">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">  return 2 // 1</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 2</span><br><span class="line">  if let currentSection: Section = Section(rawValue: section) &#123;</span><br><span class="line">    switch currentSection &#123;</span><br><span class="line">    case .createNewChannelSection:</span><br><span class="line">      return 1</span><br><span class="line">    case .currentChannelsSection:</span><br><span class="line">      return channels.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">  let reuseIdentifier = (indexPath as NSIndexPath).section == Section.createNewChannelSection.rawValue ? &quot;NewChannel&quot; : &quot;ExistingChannel&quot;</span><br><span class="line">  let cell = tableView.dequeueReusableCell(withIdentifier: reuseIdentifier, for: indexPath)</span><br><span class="line"></span><br><span class="line">  if (indexPath as NSIndexPath).section == Section.createNewChannelSection.rawValue &#123;</span><br><span class="line">    if let createNewChannelCell = cell as? CreateChannelCell &#123;</span><br><span class="line">      newChannelTextField = createNewChannelCell.newChannelNameField</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (indexPath as NSIndexPath).section == Section.currentChannelsSection.rawValue &#123;</span><br><span class="line">    cell.textLabel?.text = channels[(indexPath as NSIndexPath).row].name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于以前使用过 UITableView 的人来说，这应该是非常熟悉的，但简单地说几点:</p>
<ol>
<li>设置 Sections。请记住，第一部分将包含一个用于添加新通道的表单，第二部分将显示一个通道列表。</li>
<li>为每个部分设置行数。第一部分设置为 1，第二部分设置个数为通道的个数。</li>
<li>定义每个单元格的内容。对于第一个部分，我们将 cell 中的 text field 存储在newChannelTextField 属性中。对于第二部分，您只需将单元格的 text field 标签设置为通道名称。</li>
</ol>
<p>为了确保这一切正常工作，请在属性下面添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidAppear(_ animated: Bool) &#123;</span><br><span class="line">  super.viewDidAppear(animated)</span><br><span class="line">    </span><br><span class="line">  channels.append(Channel(id: &quot;1&quot;, name: &quot;Channel1&quot;))</span><br><span class="line">  channels.append(Channel(id: &quot;2&quot;, name: &quot;Channel2&quot;))</span><br><span class="line">  channels.append(Channel(id: &quot;3&quot;, name: &quot;Channel3&quot;))</span><br><span class="line">  self.tableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是向通道数组添加了一些虚拟通道。</p>
<p>Build and run app ; 再次登录，我们现在应该可以看到表单创建一个新的通道和三个虚拟通道:</p>
<p>太棒了! 接下来，我们需要让它与 Firebase 一起工作了。 :]</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-f5b831f7d11aa137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dummy channels"></p>
<h5 id="Firebase-数据结构"><a href="#Firebase-数据结构" class="headerlink" title="Firebase 数据结构"></a>Firebase 数据结构</h5><p>在实现实时数据同步之前，首先让我们花一会儿功夫想想数据结构。</p>
<p>Firebase database 以 NoSQL JSON 格式存储数据。</p>
<p>基本上，Firebase数据库中的所有内容都是JSON对象，而这个JSON对象的每个键都有自己的URL。</p>
<p>下面是一个说明我们的数据如何作为 JSON 对象的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;channels&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Channel 1&quot;</span><br><span class="line">    &quot;messages&quot;: &#123;</span><br><span class="line">      &quot;1&quot;: &#123; </span><br><span class="line">        &quot;text&quot;: &quot;Hey person!&quot;, </span><br><span class="line">        &quot;senderName&quot;: &quot;Alice&quot;</span><br><span class="line">        &quot;senderId&quot;: &quot;foo&quot; </span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;2&quot;: &#123;</span><br><span class="line">        &quot;text&quot;: &quot;Yo!&quot;,</span><br><span class="line">        &quot;senderName&quot;: &quot;Bob&quot;</span><br><span class="line">        &quot;senderId&quot;: &quot;bar&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Firebase 数据库支持非规范化的数据结构，因此可以为每个消息项包含 senderId。一个非规范化的数据结构意味着我们将复制大量的数据，但好处是可以更快的检索数据。</p>
<h5 id="实时-Channel-同步"><a href="#实时-Channel-同步" class="headerlink" title="实时 Channel  同步"></a>实时 Channel  同步</h5><p>首先，删除上面添加的viewDidAppear(_:)代码，然后在其他以下属性中添加以下属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private lazy var channelRef: FIRDatabaseReference = FIRDatabase.database().reference().child(&quot;channels&quot;)</span><br><span class="line">private var channelRefHandle: FIRDatabaseHandle?</span><br></pre></td></tr></table></figure>
<p>channelRef 将用于存储对数据库中通道列表的引用;channelRefHandle 将为引用保存一个句柄，以便以后可以删除它。</p>
<p>接下来，我们需要查询Firebase数据库，并得到一个在我们的表视图中显示的通道列表。添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Firebase related methods</span><br><span class="line">private func observeChannels() &#123;</span><br><span class="line">  // Use the observe method to listen for new</span><br><span class="line">  // channels being written to the Firebase DB</span><br><span class="line">  channelRefHandle = channelRef.observe(.childAdded, with: &#123; (snapshot) -&gt; Void in // 1</span><br><span class="line">    let channelData = snapshot.value as! Dictionary&lt;String, AnyObject&gt; // 2</span><br><span class="line">    let id = snapshot.key</span><br><span class="line">    if let name = channelData[&quot;name&quot;] as! String!, name.characters.count &gt; 0 &#123; // 3</span><br><span class="line">      self.channels.append(Channel(id: id, name: name))</span><br><span class="line">      self.tableView.reloadData()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      print(&quot;Error! Could not decode channel data&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ol>
<li>我们在通道引用上调用 observe:with: 方法，将句柄存储到引用。每当在数据库中添加新的通道时，就调用 completion block 。</li>
<li>completion 后接收到一个 FIRDataSnapshot (存储在快照中)，其中包含数据和其它有用的方法。</li>
<li>我们将数据从快照中提取出来，如果成功，创建一个通道模型并将其添加到我们的通道数组中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MARK: View Lifecycle</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  title = &quot;RW RIC&quot;</span><br><span class="line">  observeChannels()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">deinit &#123;</span><br><span class="line">  if let refHandle = channelRefHandle &#123;</span><br><span class="line">    channelRef.removeObserver(withHandle: refHandle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将在 view controller 加载时调用新的 observeChannels() 方法。当 view controller 通过检查 channelRefHandle 是否设置并调用    removeObserver(withHandle:) 来判断是否结束生命周期时，我们同时停止观察数据库更改。</p>
<p>在看到从 Firebase 中提取出的通道列表之前，还有一件事需要做: 提供一种方法来创建通道! 在故事板中已经设置了 IBAction，所以只需向我们的类添加以下代码就好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// MARK :Actions </span><br><span class="line">@IBAction func createChannel(_ sender: AnyObject) &#123;</span><br><span class="line">  if let name = newChannelTextField?.text &#123; // 1</span><br><span class="line">    let newChannelRef = channelRef.childByAutoId() // 2</span><br><span class="line">    let channelItem = [ // 3</span><br><span class="line">      &quot;name&quot;: name</span><br><span class="line">    ]</span><br><span class="line">    newChannelRef.setValue(channelItem) // 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是详细解释：</p>
<ol>
<li>首先检查 text field 是否拥有一个 channel name.</li>
<li>使用 childByAutoId() 唯一标志 key 创建一个通道引用。</li>
<li>创建一个字典，以此保存通道的数据。[String: AnyObject] 是类似 JSON 的对象。</li>
<li>最后，在这个新的通道上设置名称，它将自动保存到Firebase !</li>
</ol>
<p>Build and run 我们的 app ,创建一些 channels。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-a3c352bdcd94b479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Create channels"></p>
<p>所有内容都应该按照预期运行，但我们还没有实现当用户点击时可以访问其中一个通道。让我们添加以下代码来解决这个问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// MARK: UITableViewDelegate</span><br><span class="line">override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;</span><br><span class="line">  if indexPath.section == Section.currentChannelsSection.rawValue &#123;</span><br><span class="line">    let channel = channels[(indexPath as NSIndexPath).row]</span><br><span class="line">    self.performSegue(withIdentifier: &quot;ShowChannel&quot;, sender: channel)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，我们应该很熟悉了。当用户点击通道 cell 时，它会触发 ShowChannel segue。</p>
<h5 id="创建聊天界面"><a href="#创建聊天界面" class="headerlink" title="创建聊天界面"></a>创建聊天界面</h5><p>JSQMessagesViewController 是一个 UICollectionViewController 定制聊天控制类,所以我们不需要再创建自己的了! </p>
<p>这部分教程，我们将关注四点：</p>
<ol>
<li>创建消息数据。</li>
<li>创建消息泡沫。</li>
<li>删除头像支持。</li>
<li>改变 UICollectionViewCell 的 文字颜色。</li>
</ol>
<p>几乎所有需要做的事情都需要覆盖方法。JSQMessagesViewController 采用JSQMessagesCollectionViewDataSource 协议,所以我们只需要覆盖默认的实现方法就好了。</p>
<blockquote>
<p>注意:有关 JSQMessagesCollectionViewDataSource的更多信息, 请查看这里的 <a href="http://cocoadocs.org/docsets/JSQMessagesViewController/7.3.4/Protocols/JSQMessagesCollectionViewDataSource.html" target="_blank" rel="external">Cocoa 文档</a>。</p>
</blockquote>
<p>打开 ChatViewController.swift ，添加如下引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Firebase</span><br><span class="line">import JSQMessagesViewController</span><br></pre></td></tr></table></figure>
<p>将继承类 UIViewController 改为 JSQMessagesViewController：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final class ChatViewController: JSQMessagesViewController &#123;</span><br></pre></td></tr></table></figure></p>
<p>在 ChatViewController 头部，定义如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channelRef: FIRDatabaseReference?</span><br><span class="line">var channel: Channel? &#123;</span><br><span class="line">  didSet &#123;</span><br><span class="line">    title = channel?.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然 ChatViewController 继承自JSQMessagesViewController , 我们需要设置 senderId 和 senderDisplayName 的初始值，以使 app 可以唯一标识消息的发送者——即使它不知道那个人具体是谁。</p>
<p>这些需要在 view controller 首次实例化时设置。最好的设置时刻是当 segue 即将 prepare 时。回到ChannelListViewController, 添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Navigation</span><br><span class="line">override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">  super.prepare(for: segue, sender: sender)</span><br><span class="line">  </span><br><span class="line">  if let channel = sender as? Channel &#123;</span><br><span class="line">    let chatVc = segue.destination as! ChatViewController</span><br><span class="line">  </span><br><span class="line">    chatVc.senderDisplayName = senderDisplayName</span><br><span class="line">    chatVc.channel = channel</span><br><span class="line">    chatVc.channelRef = channelRef.child(channel.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将在执行 segue 之前创建的 ChatViewController 上设置属性。</p>
<p>获得 senderDisplayName 的最佳位置是当用户登录时输入他们的名字。</p>
<p>在 LoginViewController.swift，添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Navigation</span><br><span class="line">override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">  super.prepare(for: segue, sender: sender)</span><br><span class="line">  let navVc = segue.destination as! UINavigationController // 1</span><br><span class="line">  let channelVc = navVc.viewControllers.first as! ChannelListViewController // 2</span><br><span class="line">   </span><br><span class="line">  channelVc.senderDisplayName = nameField?.text // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<ol>
<li>从 segue 获取目标视图控制器并将其转换为 UINavigationController。</li>
<li>强制转换 UINavigationController 的第一个view controller 为 ChannelListViewController。</li>
<li>设置 ChannelListViewController 的senderDisplayName 为 nameField 中提供的用户名。</li>
</ol>
<p>返回 ChatViewController.swift，在 viewDidLoad() 方法最下方添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.senderId = FIRAuth.auth()?.currentUser?.uid</span><br></pre></td></tr></table></figure>
<p>这将基于已登录的 Firebase 用户设置 senderId。</p>
<p>Build and run 我们的 app 并导航到一个 channel 页面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-776c63c5ee902e62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Empty Channel"></p>
<p>通过简单地继承 JSQMessagesViewController，我们得到一个完整的聊天界面。:]</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-204b29589556dd27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fine chat app"></p>
<h5 id="设置-Data-Source-和-Delegate"><a href="#设置-Data-Source-和-Delegate" class="headerlink" title="设置  Data Source 和 Delegate"></a>设置  Data Source 和 Delegate</h5><p>现在我们已经看到了新的很棒的聊天 UI，我们可能想要开始显示消息了。但在这么做之前，我们必须注意一些事情。</p>
<p>要显示消息，我们需要一个数据源来提供符合 JSQMessageData 协议的对象，我们还需要实现一些委托方法。虽然我们可以创建符合 JSQMessageData 协议的类，但我们将使用已经提供的 JSQMessage 类。</p>
<p>在 ChatViewController 顶部，添加如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var messages = [JSQMessage]()</span><br></pre></td></tr></table></figure>
<p>messages 是应用程序中存储 JSQMessage 各种实例的数组。</p>
<p>添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: JSQMessagesCollectionView!, messageDataForItemAt indexPath: IndexPath!) -&gt; JSQMessageData! &#123;</span><br><span class="line">  return messages[indexPath.item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">  return messages.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述两种委托方法，我们并不陌生。第一个类似于 collectionView(_:cellForItemAtIndexPath:)，只是管理的对象是 message data。第二种是在每个 section 中返回messages 数量的标准方法;</p>
<h5 id="消息气泡颜色"><a href="#消息气泡颜色" class="headerlink" title="消息气泡颜色"></a>消息气泡颜色</h5><p>在  collection view 中显示的消息只是文本覆盖的图像。有两种类型的消息:传出和传入。传出的消息会显示在右边，传入的消息显示在左边。</p>
<p>在 ChatViewController 中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private func setupOutgoingBubble() -&gt; JSQMessagesBubbleImage &#123;</span><br><span class="line">  let bubbleImageFactory = JSQMessagesBubbleImageFactory()</span><br><span class="line">  return bubbleImageFactory!.outgoingMessagesBubbleImage(with: UIColor.jsq_messageBubbleBlue())</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">private func setupIncomingBubble() -&gt; JSQMessagesBubbleImage &#123;</span><br><span class="line">  let bubbleImageFactory = JSQMessagesBubbleImageFactory()</span><br><span class="line">  return bubbleImageFactory!.incomingMessagesBubbleImage(with: UIColor.jsq_messageBubbleLightGray())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在头部添加如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazy var outgoingBubbleImageView: JSQMessagesBubbleImage = self.setupOutgoingBubble()</span><br><span class="line">lazy var incomingBubbleImageView: JSQMessagesBubbleImage = self.setupIncomingBubble()</span><br></pre></td></tr></table></figure>
<p>JSQMessagesBubbleImageFactory 有创建聊天泡泡的图片方法,。JSQMessagesViewController 甚至还有一个类别提供创建消息泡沫的颜色。</p>
<p>使用 outgoingMessagesBubbleImage (:with) 和incomingMessagesBubbleImage(: with)方法,我们可以创建输入输出图像。这样，我们就有了创建传出和传入消息气泡所需的图像视图了!</p>
<p>先别太兴奋了，我们还需要实现消息气泡的委托方法。</p>
<p>#####设置气泡图像 </p>
<p>为每个 message 设置 colored bubble imag ，我们需要重载被collectionView(_:messageBubbleImageDataForItemAt:)调用的 JSQMessagesCollectionViewDataSource 方法。</p>
<p>这要求数据源提供消息气泡图像数据，该数据对应于collectionView 中的 indexPath 中的 message 项。</p>
<p>在 ChatViewController 添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: JSQMessagesCollectionView!, messageBubbleImageDataForItemAt indexPath: IndexPath!) -&gt; JSQMessageBubbleImageDataSource! &#123;</span><br><span class="line">  let message = messages[indexPath.item] // 1</span><br><span class="line">  if message.senderId == senderId &#123; // 2</span><br><span class="line">    return outgoingBubbleImageView</span><br><span class="line">  &#125; else &#123; // 3</span><br><span class="line">    return incomingBubbleImageView</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码注释:</p>
<ol>
<li>在这里检索消息。</li>
<li>如果消息是由本地用户发送的，则返回 outgoing image view。</li>
<li>相反，则返回 incoming image view.</li>
</ol>
<h5 id="移除头像"><a href="#移除头像" class="headerlink" title="移除头像"></a>移除头像</h5><p>JSQMessagesViewController 提供头像，但是在匿名 RIC app 中我们不需要或者不想使用头像。</p>
<p>在 ChatViewController 添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: JSQMessagesCollectionView!, avatarImageDataForItemAt indexPath: IndexPath!) -&gt; JSQMessageAvatarImageDataSource! &#123;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了移除 avatar image, 在每个  message’s avatar display 返回 nil 。</p>
<p>最后，在 viewDidLoad() 添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// No avatars</span><br><span class="line">collectionView!.collectionViewLayout.incomingAvatarViewSize = CGSize.zero</span><br><span class="line">collectionView!.collectionViewLayout.outgoingAvatarViewSize = CGSize.zero</span><br></pre></td></tr></table></figure>
<p>这将告诉布局，当没有 avatars 时，avatar 大小为 CGSize.zero。</p>
<p>检查 app 构建，我们可以导航到我们的一个频道;</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-5d347b3550343216.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Empty channel"></p>
<p>是时候开始对话并添加一些信息了!</p>
<h5 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h5><p>在 ChatViewController 中创建如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private func addMessage(withId id: String, name: String, text: String) &#123;</span><br><span class="line">  if let message = JSQMessage(senderId: id, displayName: name, text: text) &#123;</span><br><span class="line">    messages.append(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法创建了一个 JSQMessage，并添加到 messages 数据源中。</p>
<p>在 viewDidAppear(_:) 添加硬编码消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// messages from someone else</span><br><span class="line">addMessage(withId: &quot;foo&quot;, name: &quot;Mr.Bolt&quot;, text: &quot;I am so fast!&quot;)</span><br><span class="line">// messages sent from local sender</span><br><span class="line">addMessage(withId: senderId, name: &quot;Me&quot;, text: &quot;I bet I can run faster than you!&quot;)</span><br><span class="line">addMessage(withId: senderId, name: &quot;Me&quot;, text: &quot;I like to run!&quot;)</span><br><span class="line">// animates the receiving of a new message on the view</span><br><span class="line">finishReceivingMessage()</span><br></pre></td></tr></table></figure>
<p>Build and run，我们将看到如下效果：</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/FakeMessageData.jpg" target="_blank" rel="external"></a></p>
<p>恩，文字读起来有点不爽，它应该显示黑色的。</p>
<h4 id="消息气泡文字"><a href="#消息气泡文字" class="headerlink" title="消息气泡文字"></a>消息气泡文字</h4><p>现在我们知道，如果想在 JSQMessagesViewController 做几乎所有事情,我们只需要覆盖一个方法。要设置文本颜色，请使用老式的collectionView(_:cellForItemAt:)。</p>
<p>在 ChatViewController 中添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">  let cell = super.collectionView(collectionView, cellForItemAt: indexPath) as! JSQMessagesCollectionViewCell</span><br><span class="line">  let message = messages[indexPath.item]</span><br><span class="line">  </span><br><span class="line">  if message.senderId == senderId &#123;</span><br><span class="line">    cell.textView?.textColor = UIColor.white</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cell.textView?.textColor = UIColor.black</span><br><span class="line">  &#125;</span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息是由本地用户发送的，设置文本颜色为白色。如果不是本地用户发送的，设置文本颜色为黑色。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/FakeMessageDataEasyToRead.jpg" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-0a5bd0a189d15586.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Incoming messages"></a></p>
<p>这是一个很不错的聊天 app! 是时候让它与 Firebase 一起工作了。</p>
<h4 id="Sending-Messages"><a href="#Sending-Messages" class="headerlink" title="Sending Messages"></a>Sending Messages</h4><p>在  ChatViewController.swift 中添加如下属性：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private lazy var messageRef: FIRDatabaseReference = self.channelRef!.child(&quot;messages&quot;)</span><br><span class="line">private var newMessageRefHandle: FIRDatabaseHandle?</span><br></pre></td></tr></table></figure>
<p>这和我们在 ChannelListViewController 中添加的 channelRef、 channelRefHandle 属性相似，我们应该很熟悉了。</p>
<p>接下来，删除  ChatViewController 中的 viewDidAppear(_:) ，移除  stub test messages。</p>
<p>然后，重写以下方法，使 “发送” 按钮将消息保存到 Firebase 数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override func didPressSend(_ button: UIButton!, withMessageText text: String!, senderId: String!, senderDisplayName: String!, date: Date!) &#123;</span><br><span class="line">  let itemRef = messageRef.childByAutoId() // 1</span><br><span class="line">  let messageItem = [ // 2 </span><br><span class="line">    &quot;senderId&quot;: senderId!,</span><br><span class="line">    &quot;senderName&quot;: senderDisplayName!,</span><br><span class="line">    &quot;text&quot;: text!,</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  itemRef.setValue(messageItem) // 3</span><br><span class="line">  </span><br><span class="line">  JSQSystemSoundPlayer.jsq_playMessageSentSound() // 4</span><br><span class="line">  </span><br><span class="line">  finishSendingMessage() // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>使用 childByAutoId()，创建一个带有惟一键的子引用。</li>
<li>然后创建一个字典来存储消息。</li>
<li>接下来，保存新子位置上的值。</li>
<li>然后播放常规的 “消息发送”  声音。</li>
<li>最后，完成 “发送” 操作并将输入框重置为空。</li>
</ol>
<p>Build and run; 打开 Firebase 应用程序指示板并单击 Data 选项卡。在应用程序中发送一条消息，我们就可以看到实时显示在仪表板上的消息了:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-6966090a573224fc.gif?imageMogr2/auto-orient/strip" alt="Sending a message"></p>
<p>High five ! 我们已经可以像专业人员一样将消息保存到 Firebase 数据库了。现在消息还不会出现在屏幕上，接下来我们将处理它。</p>
<h5 id="同步-Data-Source"><a href="#同步-Data-Source" class="headerlink" title="同步 Data Source"></a>同步 Data Source</h5><p>在 ChatViewController 中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private func observeMessages() &#123;</span><br><span class="line"> messageRef = channelRef!.child(&quot;messages&quot;)</span><br><span class="line"> // 1.</span><br><span class="line"> let messageQuery = messageRef.queryLimited(toLast:25)</span><br><span class="line"> </span><br><span class="line"> // 2. We can use the observe method to listen for new</span><br><span class="line"> // messages being written to the Firebase DB</span><br><span class="line"> newMessageRefHandle = messageQuery.observe(.childAdded, with: &#123; (snapshot) -&gt; Void in</span><br><span class="line">   // 3</span><br><span class="line">   let messageData = snapshot.value as! Dictionary&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">   if let id = messageData[&quot;senderId&quot;] as String!, let name = messageData[&quot;senderName&quot;] as String!, let text = messageData[&quot;text&quot;] as String!, text.characters.count &gt; 0 &#123;</span><br><span class="line">     // 4</span><br><span class="line">     self.addMessage(withId: id, name: name, text: text)</span><br><span class="line">     </span><br><span class="line">     // 5</span><br><span class="line">     self.finishReceivingMessage()</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     print(&quot;Error! Could not decode message data&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下注解：</p>
<ol>
<li>首先创建一个查询，将同步限制到最后 25 条消息。</li>
<li>使用 .ChildAdded 观察已经添加到和即将添加到 messages 位置每个子 item。</li>
<li>从 snapshot 中提取messageData。</li>
<li>使用 addMessage(withId:name:text) 方法添加新消息到数据源。</li>
<li>通知 JSQMessagesViewController，已经接收了消息。 </li>
</ol>
<p>接下来，在 viewDidLoad() 中调用方法： observeMessages()。</p>
<p>Build and run，我们将看到我们前面输入和现在输入的所有消息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-402d03270957ef56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Messages from firebase"></p>
<p>恭喜!我们已经有一个实时聊天应用了! 现在是做一些更高级的事情的时候了，比如在用户输入的时候检测。</p>
<h5 id="检测用户何时在输入"><a href="#检测用户何时在输入" class="headerlink" title="检测用户何时在输入"></a>检测用户何时在输入</h5><p>这款应用程序最酷的功能之一就是看到 “用户正在输入” 的指示器。当小气泡弹出时，你知道另一个用户在键盘上打字。这个指标非常重要，因为它可以避免我们发送那些尴尬的 “你还在吗?” 消息。</p>
<p>检测打字有很多方法，但 textViewDidChange(_:) 是一个很好的检查时机。将以下内容添加到ChatViewController的底部:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func textViewDidChange(_ textView: UITextView) &#123;</span><br><span class="line">  super.textViewDidChange(textView)</span><br><span class="line">  // If the text is not empty, the user is typing</span><br><span class="line">  print(textView.text != &quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要确定用户是否在输入，请检查 textview . text 的值。如果这个值不是空字符串，那么您就知道用户已经键入了一些东西。</p>
<p>通过 Firebase ，  当用户输入时我们可以更新 Firebase 数据库。然后，为了响应数据库更新这个指示，我们可以显示 “用户正在输入” 指示器。</p>
<p>为了实现目的，在 ChatViewController 中添加如下属性：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private lazy var userIsTypingRef: FIRDatabaseReference = </span><br><span class="line">  self.channelRef!.child(&quot;typingIndicator&quot;).child(self.senderId) // 1</span><br><span class="line">private var localTyping = false // 2</span><br><span class="line">var isTyping: Bool &#123;</span><br><span class="line">  get &#123;</span><br><span class="line">    return localTyping</span><br><span class="line">  &#125;</span><br><span class="line">  set &#123;</span><br><span class="line">    // 3</span><br><span class="line">    localTyping = newValue</span><br><span class="line">    userIsTypingRef.setValue(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是我们需要了解的这些特性:</p>
<ol>
<li>创建一个用于跟踪本地用户是否正在输入的 Firebase 引用。</li>
<li>新增私有属性，标记本地用户是否在输入。</li>
<li>每次更改时，使用计算属性更新 localTyping 和 userIsTypingRef。</li>
</ol>
<p>现在，添加如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private func observeTyping() &#123;</span><br><span class="line">  let typingIndicatorRef = channelRef!.child(&quot;typingIndicator&quot;)</span><br><span class="line">  userIsTypingRef = typingIndicatorRef.child(senderId)</span><br><span class="line">  userIsTypingRef.onDisconnectRemoveValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法创建一个名为 typingIndicator 的通道的子引用，它是我们更新用户输入状态的地方。我们不希望这些数据在用户注销之后仍然逗留，因此我们可以在用户使用后删除它 onDisconnectRemoveValue()。</p>
<p>添加以下内容调用新方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidAppear(_ animated: Bool) &#123;</span><br><span class="line">  super.viewDidAppear(animated)</span><br><span class="line">  observeTyping()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换 textViewDidChange(_:) 中的 print(textView.text != “”) ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isTyping = textView.text != &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>这只是在用户输入时设置 isTyping。</p>
<p>最后，在 didPressSend(_:withMessageText:senderId:senderDisplayName:date:): 后面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isTyping = false</span><br></pre></td></tr></table></figure></p>
<p>当按下 Send 按钮时，这将重置输入指示器。</p>
<p>Build and run，打开Firebase应用程序仪表板查看数据。当我们键入消息时，我们应该可以看到为用户提供的类型指示器记录更新:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-157a7ff101cd9e6a.gif?imageMogr2/auto-orient/strip" alt="Typing indicator"></p>
<p>我们现在已经知道什么时候用户在输入了，接下来是显示指示器的时候了。</p>
<h4 id="查询正在输入的用户"><a href="#查询正在输入的用户" class="headerlink" title="查询正在输入的用户"></a>查询正在输入的用户</h4><p>“用户正在输入”  指示符应该在除本地用户外任何用户键入时显示，因为本地用户在键入时自己已经知道啦。</p>
<p>使用 Firebase query ，我们可以检索当前正在键入的所有用户。在 ChatViewController  中添加如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private lazy var usersTypingQuery: FIRDatabaseQuery = </span><br><span class="line">  self.channelRef!.child(&quot;typingIndicator&quot;).queryOrderedByValue().queryEqual(toValue: true)</span><br></pre></td></tr></table></figure></p>
<p>这个属性保存了一个 FIRDatabaseQuery，它就像一个 Firebase 引用，但它是有序的。通过检索所有正在输入的用户来初始化查询。这基本上是说，“嘿，Firebase，查询关键字 / typing 指示器，然后给我所有值为 true 的用户。”</p>
<p>接下来，在  observeTyping() 添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">usersTypingQuery.observe(.value) &#123; (data: FIRDataSnapshot) in</span><br><span class="line">  // 2 You&apos;re the only one typing, don&apos;t show the indicator</span><br><span class="line">  if data.childrenCount == 1 &amp;&amp; self.isTyping &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 3 Are there others typing?</span><br><span class="line">  self.showTypingIndicator = data.childrenCount &gt; 0</span><br><span class="line">  self.scrollToBottom(animated: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<ol>
<li>我们使用 .value 监听状态，当其值改变时，该 ompletion block  将被调用。</li>
<li>我们需要知道在查询中有多少用户，如果仅仅只有本地用户，不显示指示器。</li>
<li>如果有用户，再设置指示器显示。调用 scrolltobottom 动画以确保显示指示器。</li>
</ol>
<p>在 build and run 之前，拿起一个物理 iOS 设备，测试这种情况需要两个设备。一个用户使用模拟器，另一个用户使用真机。</p>
<p>现在，同时 build and run 模拟器和真机，当一个用户输入时，另外用户可以看到指示器出现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-9829fac8efcfc977.gif?imageMogr2/auto-orient/strip" alt="Multi-user typing indicator"></p>
<p>现在我们有了一个打字指示器，但我们还缺少一个现代通讯应用的一大特色功能——发送图片!</p>
<h5 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h5><p>要发送图像，我们将遵循与发送文本相同的原则，其中有一个关键区别: 我们将使用 Firebase 存储，而不是直接将图像数据存储在消息中，这更适合存储音频、视频或图像等大型文件。</p>
<p>在  ChatViewController.swift 中添加 Photos ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Photos</span><br></pre></td></tr></table></figure></p>
<p>接下来，添加如下属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazy var storageRef: FIRStorageReference = FIRStorage.storage().reference(forURL: &quot;YOUR_URL_HERE&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这是一个 Firebase 存储引用，概念上类似于我们已经看到的 Firebase 数据库引用，但是对于存储对象来说，用你的 Firebase 应用程序 URL 替换YOUR_URL_HERE，我们可以在你的应用程序控制台中点击存储。<br><img src="http://upload-images.jianshu.io/upload_images/130752-189474f3b3774ad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Firebase console storage"></p>
<p>发送照片信息需要一点点的 smoke 和 mirrors ，而不是在这段时间阻塞用户界面，这会让你的应用感觉很慢。保存照片到Firebase 存储返回一个URL，这可能需要几秒钟——如果网络连接很差的话，可能需要更长的时间。我们会用一个假的URL发送照片信息，并在照片保存后更新消息。</p>
<p>添加如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private let imageURLNotSetKey = &quot;NOTSET&quot;</span><br></pre></td></tr></table></figure></p>
<p>并添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func sendPhotoMessage() -&gt; String? &#123;</span><br><span class="line">  let itemRef = messageRef.childByAutoId()</span><br><span class="line"></span><br><span class="line">  let messageItem = [</span><br><span class="line">    &quot;photoURL&quot;: imageURLNotSetKey,</span><br><span class="line">    &quot;senderId&quot;: senderId!,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  itemRef.setValue(messageItem)</span><br><span class="line"></span><br><span class="line">  JSQSystemSoundPlayer.jsq_playMessageSentSound()</span><br><span class="line"></span><br><span class="line">  finishSendingMessage()</span><br><span class="line">  return itemRef.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这很像我们之前实现的 didPressSend(_:withMessageText:senderId:senderDisplayName:date:) 方法。</p>
<p>现在，我们需要能够在获取映像的 Firebase 存储 URL之后更新消息。添加以下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func setImageURL(_ url: String, forPhotoMessageWithKey key: String) &#123;</span><br><span class="line">  let itemRef = messageRef.child(key)</span><br><span class="line">  itemRef.updateChildValues([&quot;photoURL&quot;: url])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要允许用户选择要发送的图像。幸运的是 JSQMessagesViewController 已经包含添加一个图像到我们消息的 UI ,所以我们只需要实现对应的方法处理点击就好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override func didPressAccessoryButton(_ sender: UIButton) &#123;</span><br><span class="line">  let picker = UIImagePickerController()</span><br><span class="line">  picker.delegate = self</span><br><span class="line">  if (UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceType.camera)) &#123;</span><br><span class="line">    picker.sourceType = UIImagePickerControllerSourceType.camera</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    picker.sourceType = UIImagePickerControllerSourceType.photoLibrary</span><br><span class="line">  &#125;</span><br><span class="line">     </span><br><span class="line">  present(picker, animated: true, completion:nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，如果设备支持拍照，将弹出摄像机，如果不支持，会弹出相册。</p>
<p>接下来,当用户选择图像，我们需要实现 UIImagePickerControllerDelegate方法来处理。将以下内容添加到文件的底部(在最后一个关闭括号之后):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Image Picker Delegate</span><br><span class="line">extension ChatViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123;</span><br><span class="line">  func imagePickerController(_ picker: UIImagePickerController, </span><br><span class="line">    didFinishPickingMediaWithInfo info: [String : Any]) &#123;</span><br><span class="line">      </span><br><span class="line">    picker.dismiss(animated: true, completion:nil)</span><br><span class="line"></span><br><span class="line">    // 1</span><br><span class="line">    if let photoReferenceUrl = info[UIImagePickerControllerReferenceURL] as? URL &#123;</span><br><span class="line">      // Handle picking a Photo from the Photo Library</span><br><span class="line">      // 2</span><br><span class="line">      let assets = PHAsset.fetchAssets(withALAssetURLs: [photoReferenceUrl], options: nil)</span><br><span class="line">      let asset = assets.firstObject</span><br><span class="line">      </span><br><span class="line">      // 3</span><br><span class="line">      if let key = sendPhotoMessage() &#123;</span><br><span class="line">        // 4 </span><br><span class="line">        asset?.requestContentEditingInput(with: nil, completionHandler: &#123; (contentEditingInput, info) in</span><br><span class="line">          let imageFileURL = contentEditingInput?.fullSizeImageURL</span><br><span class="line">          </span><br><span class="line">          // 5</span><br><span class="line">          let path = &quot;\(FIRAuth.auth()?.currentUser?.uid)/\(Int(Date.timeIntervalSinceReferenceDate * 1000))/\(photoReferenceUrl.lastPathComponent)&quot;</span><br><span class="line"></span><br><span class="line">          // 6</span><br><span class="line">          self.storageRef.child(path).putFile(imageFileURL!, metadata: nil) &#123; (metadata, error) in</span><br><span class="line">            if let error = error &#123;</span><br><span class="line">              print(&quot;Error uploading photo: \(error.localizedDescription)&quot;)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">            // 7</span><br><span class="line">            self.setImageURL(self.storageRef.child((metadata?.path)!).description, forPhotoMessageWithKey: key)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Handle picking a Photo from the Camera - TODO</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123;</span><br><span class="line">    picker.dismiss(animated: true, completion:nil)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>首先，从 info dictionary 获取图像。</li>
<li>调用  sendPhotoMessage() 方法，保存图像 URL 到 Firebase 数据库。</li>
<li>接下来，我们将得到照片的 JPEG 表示，准备发送到 Firebase 存储。</li>
<li>如前所述，根据用户的惟一 id 和当前时间创建一个独特的 URL。</li>
<li>创建一个 FIRStorageMetadata 对象并将元数据设置为 image / jpeg。</li>
<li>然后保存图像到 Firebase 数据库。</li>
<li>图像被保存后，我们将再次调用 setImageURL() 方法。</li>
</ol>
<p>几近完美! 现在我们已经建立了可以将图像数据保存到 Firebase 并将 URL 保存到消息数据存储中的应用程序，但我们还没有更新应用程序来显示这些照片。接下来我们来解决这个问题。</p>
<h4 id="展示图像"><a href="#展示图像" class="headerlink" title="展示图像"></a>展示图像</h4><p>首先，在 ChatViewController 中添加属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var photoMessageMap = [String: JSQPhotoMediaItem]()</span><br></pre></td></tr></table></figure>
<p>它包含一个 jsqphotomediaitem 数组。</p>
<p>现在，我们需要为 addMessage (withId:name:text:) 创建一个兄弟方法。添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private func addPhotoMessage(withId id: String, key: String, mediaItem: JSQPhotoMediaItem) &#123;</span><br><span class="line">  if let message = JSQMessage(senderId: id, displayName: &quot;&quot;, media: mediaItem) &#123;</span><br><span class="line">    messages.append(message)</span><br><span class="line"></span><br><span class="line">    if (mediaItem.image == nil) &#123;</span><br><span class="line">      photoMessageMap[key] = mediaItem</span><br><span class="line">    &#125;</span><br><span class="line">    collectionView.reloadData()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果图像键尚未设置，则将 JSQPhotoMediaItem 存储在新属性中。这允许我们在稍后设置图像时检索并更新消息。</p>
<p>我们还需要能够从 Firebase 数据库获取图像数据，以便在UI中显示它。添加以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private func fetchImageDataAtURL(_ photoURL: String, forMediaItem mediaItem: JSQPhotoMediaItem, clearsPhotoMessageMapOnSuccessForKey key: String?) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let storageRef = FIRStorage.storage().reference(forURL: photoURL)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  storageRef.data(withMaxSize: INT64_MAX)&#123; (data, error) in</span><br><span class="line">    if let error = error &#123;</span><br><span class="line">      print(&quot;Error downloading image data: \(error)&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    storageRef.metadata(completion: &#123; (metadata, metadataErr) in</span><br><span class="line">      if let error = metadataErr &#123;</span><br><span class="line">        print(&quot;Error downloading metadata: \(error)&quot;)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 4</span><br><span class="line">      if (metadata?.contentType == &quot;image/gif&quot;) &#123;</span><br><span class="line">        mediaItem.image = UIImage.gifWithData(data!)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        mediaItem.image = UIImage.init(data: data!)</span><br><span class="line">      &#125;</span><br><span class="line">      self.collectionView.reloadData()</span><br><span class="line">      </span><br><span class="line">      // 5</span><br><span class="line">      guard key != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      self.photoMessageMap.removeValue(forKey: key!)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>获取存储映像的引用。</li>
<li>从存储中获取对象。</li>
<li>从存储中获取图像元数据。</li>
<li>如果元数据显示图像是 GIF，我们需要使用 UIImage 类别，它通过 SwiftGifOrigin Cocapod 被拉进来。这是需要的，因为 UIImage 不处理 GIF 图像。否则我们只需要用普通的 UIImage 就可以了。</li>
<li>最后，我们从 photoMessageMap 中删除键，现在我们已经获取了图像数据。</li>
</ol>
<p>最后，我们需要更新 observeMessages()。在 if 语句中，但在 else 条件之前，添加以下测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if let id = messageData[&quot;senderId&quot;] as String!,</span><br><span class="line">        let photoURL = messageData[&quot;photoURL&quot;] as String! &#123; // 1</span><br><span class="line">  // 2</span><br><span class="line">  if let mediaItem = JSQPhotoMediaItem(maskAsOutgoing: id == self.senderId) &#123;</span><br><span class="line">    // 3</span><br><span class="line">    self.addPhotoMessage(withId: id, key: snapshot.key, mediaItem: mediaItem)</span><br><span class="line">    // 4</span><br><span class="line">    if photoURL.hasPrefix(&quot;gs://&quot;) &#123;</span><br><span class="line">      self.fetchImageDataAtURL(photoURL, forMediaItem: mediaItem, clearsPhotoMessageMapOnSuccessForKey: nil)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们逐行解释：</p>
<ol>
<li>首先，检查你是否有一个photoURL集。</li>
<li>如果可以，创建一个新的 JSQPhotoMediaItem。这个对象封装了消息中的富媒体——正是你所需要的!</li>
<li>调用 addPhotoMessage 方法。</li>
<li>最后，检查一下，确保 photoURL 包含一个 Firebase 存储对象的前缀。如果是，获取图像数据。</li>
</ol>
<p>现在只剩下最后一件事了，你能猜到是什么么？</p>
<p>当你在解码照片信息时，你只是在你第一次观察图像数据时才这样做。但是，你还需要观察稍后发生的消息的任何更新，比如在将图像 URL 保存到存储后更新它。</p>
<p>添加下面属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var updatedMessageRefHandle: FIRDatabaseHandle?</span><br></pre></td></tr></table></figure>
<p>在 observeMessages() 底部添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// We can also use the observer method to listen for</span><br><span class="line">// changes to existing messages.</span><br><span class="line">// We use this to be notified when a photo has been stored</span><br><span class="line">// to the Firebase Storage, so we can update the message data</span><br><span class="line">updatedMessageRefHandle = messageRef.observe(.childChanged, with: &#123; (snapshot) in</span><br><span class="line">  let key = snapshot.key</span><br><span class="line">  let messageData = snapshot.value as! Dictionary&lt;String, String&gt; // 1</span><br><span class="line">    </span><br><span class="line">  if let photoURL = messageData[&quot;photoURL&quot;] as String! &#123; // 2</span><br><span class="line">    // The photo has been updated.</span><br><span class="line">    if let mediaItem = self.photoMessageMap[key] &#123; // 3</span><br><span class="line">      self.fetchImageDataAtURL(photoURL, forMediaItem: mediaItem, clearsPhotoMessageMapOnSuccessForKey: key) // 4</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>从 Firebase 快照中获取消息数据字典。</li>
<li>检查字典是否有一个 photoURL 键集。</li>
<li>如果是这样，则从缓存中提取 JSQPhotoMediaItem。</li>
<li>最后，获取图像数据并使用图像更新消息!</li>
</ol>
<p>当 ChatViewController 消失时，我们需要做的最后一件事就是整理和清理。添加以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">  if let refHandle = newMessageRefHandle &#123;</span><br><span class="line">    messageRef.removeObserver(withHandle: refHandle)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if let refHandle = updatedMessageRefHandle &#123;</span><br><span class="line">    messageRef.removeObserver(withHandle: refHandle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Build and run 应用程序; 我们就应该能够在聊天中点击小的 paperclip 图标发送照片或图片信息了。注意这些消息何时显示一个等待的小 spinner—— 当我们的应用程序保存照片数据到 Firebase 存储的时候。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-e159da58121447fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Send photos"></p>
<p>Kaboom! 我们刚刚做了一个说大也大说小也小、实时的、用户可以输入照片和 GIF 的聊天应用程序。</p>
<p>####Where to Go From Here?</p>
<p>Demo 下载地址： <a href="https://koenig-media.raywenderlich.com/uploads/2016/09/ChatChatFirebaseTutorial-finished.zip" target="_blank" rel="external">completed project</a> </p>
<p>我们现在知道 Firebase 和 JSQMessagesViewController 的基本知识，但还有很多你可以做，包括 one-to-one messaging、social authentication、头像显示等。</p>
<p>想更多了解，请查阅 <a href="https://firebase.google.com/docs/ios" target="_blank" rel="external">Firebase iOS documentation</a>.</p>
<p> – 2017.10.24<br>上海 虹桥V1</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Joey Chang" />
          <p class="site-author-name" itemprop="name">Joey Chang</p>
          <p class="site-description motion-element" itemprop="description">读书、写字、周游天下...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">61</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/iJoeychang" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/9a969b4dae83/latest_articles" target="_blank">
                  
                    <i class="fa fa-home"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3490688707" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joey Chang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>位到访者



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"joeychang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  


  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>



</body>
</html>
