<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="读书、写字、周游天下...">
<meta property="og:type" content="website">
<meta property="og:title" content="Joey  chang's  blog">
<meta property="og:url" content="http://ijoeychang.github.io/page/2/index.html">
<meta property="og:site_name" content="Joey  chang's  blog">
<meta property="og:description" content="读书、写字、周游天下...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joey  chang's  blog">
<meta name="twitter:description" content="读书、写字、周游天下...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Joey  chang's  blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7051b02e64de9396c8130272189f6a4d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Joey  chang's  blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/2017/香港两日/" itemprop="url">
                  香港两日
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-29T22:40:00+08:00" content="2017-10-29">
              2017-10-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/周游天下/" itemprop="url" rel="index">
                    <span itemprop="name">周游天下</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/29/2017/香港两日/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/29/2017/香港两日/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周末去了趟香港。</p>
<p>去年十二月份的时候，去了趟深圳，和大学室友在深圳转了两天，其中第二天去了红树林风景区，那里和香港隔河相望，当时因为还没有办通行证，眼看着香港就那么近了却不能过去，那种感觉甚是难受啊。</p>
<p>今年上半年，我就早早的办了个护照和通行证，打算今年一定要到香江（香港）转一转的。</p>
<p>原本计划国庆节之前要做个小手术，把左手腕处已经存在多年的腱鞘囊肿切除，然后趁着假期好好养养伤口，然而因为医院就医的人实在多，我提前两天去，手术竟然一直预约到节后两周的日子才做。上周五刚做完手术，也没挡得住我要去香港，周六一早（早上五点）我就向机场赶去。好多年不习惯早起了，那天早起，早上感觉很困，很难受，可是一想到这是要去香港，要去我打小就向往的地方，我还是挺兴奋的。</p>
<p>一切都很顺利，飞机没有延误，还提前半小时到达了深圳。我要在深圳和同学先集合，然后再一起出关入港。</p>
<p>到了深圳，和张华、刘岩、马雷在福田口岸集合。人到齐的时候，差不多十点。</p>
<p>出入海关，需要两步，进出香港，先要一边海关放行，然后再要另一边海关准入。想想香港都回归二十年了，往返竟然还这么麻烦。</p>
<p>在海关还有个小插曲，我们一行四人差点走丢。因为香港那边还是比较国际化的，中国移动和中国联通，如果不办理特别套餐，在香港那边不能使用。</p>
<p>因为张华和我是第一次进入香港，虽然我们的通行证是磁卡，但是仍然需要走人工柜台，马雷用的是本本儿通行证，需要人工审核。开始我们不知道，于是马雷去人工审核那边排队了，我们三人走自动刷卡通道，刘岩顺利通行，可是我和华子被卡着了。我和华子无奈，只好去走人工审核通道，因为跟着人群和路标指示，又没有走马雷走的那一边，我们被指引到地下一层了。再出来的时候，发现手机都没信号了。当时有点小慌张，心想可别人再走丢了啊。</p>
<p>好在马雷他们两个先到，然后就一直在二楼电梯入口处那里等待，我们终于再次集合完毕。</p>
<p>这里说一下，海关审核的时候，香港那边的工作人员，虽然同样说的是粤语，却给人感觉怪怪的，不像深圳那边那样本土，香港的粤语，有点像电影里演员们说普通话带着浓重口音的那种感觉。不得不说，有些香港人对大陆人不是很友好，从他们说话语气和态度中可以知道。</p>
<p>进了海关，先要用港币（在深圳出关时兑换的，0.85 元兑换 1 港币）购买香港地铁票。票有一日通、八达通和单程票几种。如果只在香港待一天，然后想多逛些地方的话，一日通最实惠，100 港币一天，地铁差不多可以任意坐，不过只能两次往返海关。八达通可以自由充值，适合长期使用。单程票，则和其它地方的地铁单程票一样了。</p>
<p>坐上地铁，里面人还是蛮挤的，竟然没座儿，地铁第一站就坐得满满的，从第一站上车的，应该大部分都是大陆这边去旅游的。</p>
<p>香港的地铁，给人感觉很有古风，里面广告很像日本广告，风格和上海深圳这边完全不一样的，再有感觉就是破，包括香港地铁，还有香港的大楼，给人的感觉都是破旧，我想这应该是它们发展得早，存在的时间太长了吧。</p>
<p>我们第一站要去逛逛香港的闹市，然后去历史博物馆。</p>
<p>在香港的主要步行街走的时候，感觉他们的路很窄，有的地方，单行道仅仅能容得下一人行走，他们的大街也很窄，我们讨论，可能放在几十上百年前，那样的路已经很宽了，可是放在现在，他们显得很狭窄很拥挤，路上来来往往的车辆，会经常堵车。</p>
<p>再有就是，香港是靠左行走的，无论车辆还是行人，都是靠左走。刚开始我们很不适应，潜意识里都是靠右走，有时会和路人走个撞面，然后才意识到自己错了。不仅车道靠左，车辆内部的驾驶座儿也是不同于大陆的车辆的，他们的驾驶座位在右边。</p>
<p>中午在一条卖衣服的小街边的餐馆吃了碗面，小餐馆的老板一副爱答不理的样子，他竟然自始至终没有说一句话，一副冷冰冰的模样。不过面还算好吃，里面的肉给得很足，这点比大陆饭店做得好，我们这边碗里的肉都是肉沫，用筷子一搅就找不到了，他们那边却是实实在在的几大片肉。</p>
<p>香港那边消费很高，我吃的那碗面 36 港币一碗。在路边一家饭店门前看到一则招聘广告，洗碗工月工资一万三，想想自己的收入，我们不禁感慨，“ x , 我们来这里洗碗吧！”</p>
<p>下午我们在历史博物馆转了好几个小时。历史博物馆，里面倒没多少吸引人的真迹，不过在那里看了些纪录片和化石，才知道原来香港有人类的历史已经很久很久了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-41a5327a125ddc5b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港博物馆"></p>
<p>香港那边，国际化的味道很浓。在博物馆里面，好多参观者是老外。在馆里听着一个导游用不算特别流利的英语向六七个老外一处处的做讲解，在林则徐销烟展览处，听着那段让国人不堪回首的历史，不知道老外们做何感受。</p>
<p>我喜欢漫步在历史长河的画卷中，我喜欢在那样的氛围里任思绪遐想。悠悠岁月，茫茫大海，遥遥数千年，如果我活在古代，我会是什么身份呢？</p>
<p>我背着肩包行走在展览香港民俗的场景中，一个弯腰，肩包边斜插着的矿泉水掉在了地下，我还没来得及弯腰去拾，不远处一个胖胖的外国女士跑来弯腰拾起那瓶水，然后递给了我。我有点意外，然后冲她大声说了句，“ Thank you… ” 她冲我笑笑，没有说话，有点羞涩得走开了。</p>
<p>香港是很国际化的，到处是外国人，即使你旁边站着一个和你一样黄皮肤黑眼睛的人，他也很有可能来自南亚、东南亚、日本等国。在地铁里，旁边坐了个哥们，看他在认真看一本小书，我瞥了一眼，竟然是日文书。那哥们儿很有可能是日本人啊，谁知道呢，反正看不出来。我去化妆品店里，去零食店里，有服务员都用日语冲我招呼。他们可能认为我是日本人吧，当然我听不懂日文，也没有理她们。</p>
<p>在博物馆，因为一人漫步在想象里，我比他们几个走得慢。走着走着，几个人就走散了。等我觉得差不多可以出馆了，却发现找不到他们人了。我一个人去博物馆出口处等他们，等了三四十分钟，仍然不见人，我想他们不至于把我丢下先走吧。因为人生地不熟的，又因为电话打不通，时间长了，看着天慢慢就要黑，真有点着急，最后还是我等不下去了，我又进去博物馆重新走了一遍，最后在二楼电梯那边遇到刘岩。看到他第一眼，他就说已经在那里等我很久了。我也说在下面等他们很久了。后来找到马雷他们，我说，“我一直在下面出口的地方等你们，等了有四十分钟了，想着你们肯定还在博物馆里，然后我就坐在出口处等，我要守株待兔。” 刘岩说，“开始你在我们后面，我们在那里等你，也是守株待兔…” 听得出他有点不喜欢守株待兔这个词，我哈哈大笑…</p>
<p>出了博物馆，我们一行顺着路直走，要去维多利亚港了。</p>
<p>本来我想先看看星光大道，想和李小龙合影留念的，想当年，在我最难熬的日子里，李小龙精神给了我很大支撑，就是喜欢他那种精神，他的四部半电影，我曾看了多遍，还看过他的传记电视剧，感觉李真伟大啊，可惜天妒英才，让他早早过世，不然香港电影应该还会多出很多经典电影来。</p>
<p>那天很不巧，因为在修路，星光大道景点过不去。实在太遗憾了。</p>
<p>已经到了港口，海边的风景真的好棒，有点像上海的外滩，可是那河那江比黄浦江宽多了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-4ecc97e9b5612a20.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港留念"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-14e57204276dcf4e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维多利亚港"></p>
<p>港口那边很好看，人也很多，人来人往中，我听到有人在唱三毛的歌，“不要问我从哪里来… ” 我看了看他们，只见中间一位女士在高歌，旁边有两位中年男子在吹着不同的乐器在伴奏，他们在卖艺。</p>
<p>让人意外的是，他们旁边还有一个老外坐在地上玩弄着两个铁球，他在耍杂技，他在乞讨。老外也有穷人，也有乞丐。想想国内老外的身份地位一般较高，在香港看到他们乞讨，真有些意外了。</p>
<p>让人更意外的是，那里还有人在光明正大的宣传法轮功，看我们走近，她还向我们发传单，当然我们都没有接受。香港果然是很开放的地方，这在国内，是万万不被允许的。</p>
<p>坐船穿过维多利亚港，大概十五分钟的样子，船票只要 3块7港币，非常实惠。在自动购票机排队购票的时候，因为第一次用，还不怎么会玩儿，我们在那观看了好一会儿，这时来了几个老外，他们也要买票，其中一人对我说了句什么，我没听懂，然后我让他们先买了，买前买后，他都说了谢谢。在那里，英语不好真为难啊，想着在国外应该更甚。这次去香港，应该可以算为以后出国旅游先铺垫一下。在海外，不是你好不好意思说英语的问题，有时是你必须说啊！这再次坚定我要拿下英语听说能力的态度，我想赚老外的钱，想赚  dollar。</p>
<p>到了港口对岸，走不远就是香港有名的两家苹果商店其中之一了。我们去那里观看，三层楼都是苹果店，很豪华，人很多。我算了下，一个 iPhone 8 比内地可以便宜八百块。看着那么多喜欢的苹果产品，真想购买，想想还要存钱办正事，只好忍住了。心想以后要买了再过来吧。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-6183e09cc1e56f2c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apple store "></p>
<p>出了苹果商店，天色已然侵夕，华灯初上，灯火辉煌，我们沿路步行，想去香港回归纪念处看看。看着很近的距离，可是走了一会儿，发现那里还是很远，我们在水边休息了会儿，贪看了美丽的夜色，然后就准备归程了。那里草坪上有很多人在组建 party ,他们很多应该是印度人。几个人坐在地上围在一起或吃饭或聊天，应该是他们的风俗。在灯光辉煌的夜色里，坐在草坪上夜话，那样感觉应该不错的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-20bce92b4e99540b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港的夜"></p>
<p>回去的时候，在商店够买了些物品，然后就回深圳了。在香港的第一天就此结束。</p>
<p>第二天，这次和我一起去的是泉泉，第一天走了好多路，另外三人已经累坏了。</p>
<p>第二天一早，本着早去早回的想法，我们俩一早就从深圳出发到了香港。</p>
<p>这次来就没什么特意想逛的了，我说要不我们去香港大学转转吧，泉泉说好。</p>
<p>到了香港大学，让人有点失望，猛一看，那里哪像是大学！明明像商场和住宅区。可是那里却真真切切是享誉中外的港大。</p>
<p>大学综合排名，港大曾有全亚洲第二全港第一的名次，比北大清华还要靠前很多。国父宋中山，作家张爱玲，词人林夕，都是港大的校友。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-66db5fd3ec5d8229.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港大学"></p>
<p>香港作为一个弹丸之地，在经济，文化上能产出如此深远影响，我想应该和它的全球得天独厚的地理位置有关，加之被日本、英国统治过，英语作为港人的最重要语言之一，在学术上，他们可以和国际最前沿的科技无缝衔接，加上香港经济繁荣，作为全球顶级的金融中心，港大成绩突出就不足为怪了。</p>
<p>我和泉泉在港大溜达了好一会儿，因为校园在半山腰上，在教学楼里，你很难发现自己身处楼层第几层。</p>
<p>我们俩漫无目的的走，后来竟然到了学校后面的龙虎山。那里有稀稀疏疏的人在爬山，我俩顺着山路上行，想爬到顶层遥看不远处的维多利亚美景。可惜因为走了太多路实在累，也因为要赶着时间回深圳，我们竟然没有爬到山顶。爬有一半多点就原路返回了，甚为遗憾。</p>
<p>下山后，我们混作学生在学校餐厅吃了饭，吃的是咖喱牛肉饭，南方的饭让人吃不习惯，但那饭菜还可以，相对于学校外面，价格也实惠。</p>
<p>在港大，我才深深体会到什么是 “大学之大不在高楼而在大师”，我想此生自己与名校无缘，希望以后有孩子了可以培养他到海外学习。</p>
<p>吃过饭在路边休息的时候，有六七个年轻人走过来说想和我俩一起合个照。没搞明白怎么回事时我们就同意了。事后泉泉一直担心会不会是个什么骗局。我想他真是处事小心谨慎啊。那几个人应该是港大学生，他们中有两三个老外，其中一位妹子说是他们老师给他们布置的无聊作业。不知真假。</p>
<p>离开港大，我们一起出去逛，想买些化妆品和零食带回去。没想到在地铁里又遇见两件让我难忘的事。</p>
<p>其一是，某次进地铁，我俩刚下电梯，听到地铁门在嘟嘟，泉泉蹭的一下跑了进去，我没进去，地铁就关门了。好好不尴尬啊！地铁门关了，泉泉在里面比划着，我理解为他说我们下一站见。</p>
<p>再来地铁，我进去，到下一站，我下来了，可是一看车站里面没泉泉，还在担心是不是我理解错了，在车外我向后走了一车节，正好看到泉泉在门口，我又赶快跳进车里。泉泉说他上车看看我有没有理解错误。幸好找到人了，不大一会儿车就开了，一场虚惊。这有手机不能用，还真没安全感。</p>
<p>不过还好，有的商店里可以蹭 WiFi 。</p>
<p>再有一件，当我们坐车回深圳的时候，遇到了一位和蔼可亲、和颜善目的老太太。</p>
<p>开始源于在地铁里让座。我给老人让座，然后站在了她旁边，她也是刚被他人让座，然后说了好几声谢谢，她看到我左手腕包扎着，说，“小伙子，你看你的手都坏了还让座，来，你坐我这儿吧。”</p>
<p>我忙说，“不用，不用，我们马上就下车了，嘿嘿…”</p>
<p>老太太问，“你是哪里人啊？”</p>
<p>我答，“河南郑州”。我本来想说开封呢，怕她不知道，然后说了郑州。</p>
<p>她很高兴，“啊，原来是郑州的啊，我年轻的时候去过那里，那里交通很便利，铁路，公路，航空都很发达。”</p>
<p>我说是的。</p>
<p>她又问，“来香港几天了？”</p>
<p>我说，“两天，我们这正要回去呢。”</p>
<p>老太太说，“两天哪够啊，既然来了，还不多玩几天再走，香港有迪士尼，郑州没有，还有海洋公园，都很好玩的，应该去转转。”</p>
<p>我笑着说时间太赶了。</p>
<p>到了要换乘下车的地方，我们竟然在同一个站下车。虽然出了地铁走的路不一样，可是到了另外线路地铁，我们又碰面了。老太太看到我又聊了起来。</p>
<p>这次我知道，原来她要去墓地，她说，“我先生去世好多年了，我现在要去墓地祭拜他，今天我的孩子们也去。他们花了几十万买了一块儿墓地，两人墓位，等我老了也会去那里。我真是沾了我先生的光了。哎，其实人死后就那回事儿，骨灰洒在大海里也不错的。我今年 79 岁了，一个人住，不给孩子们找麻烦。”</p>
<p>我说，“这边消费水平真高啊。”</p>
<p>她说，“是的。越是内地来的，越觉得贵。特别房价贵，这是个世界性问题，哪里都一样的。这些年，大陆那边过来的人也多了。这里也经常过些国人节日，每年七月中，也过中元节，也是鬼节，很热闹了…”</p>
<p>看她那么大年纪了还一个人出门，我真有点心疼啊。</p>
<p>要进地铁的时候，老太太走得很快，边走边喊我们，“来，来，走这里…”</p>
<p>她一副轻车熟路的样子，走路很快，我们跟着她多走了两个入口才进地铁。</p>
<p>到了地铁里面，有位姑娘想给她让座，她挥挥手说，“不用不用，谢谢”。然后她站在一个门口，倚靠着座位边的铁架子继续和我们聊天。</p>
<p>她笑着说，“现在的孩子都挺有礼貌的。”</p>
<p>又说，“我年轻的时候当兵，五六年去过郑州，我有个表哥是郑州的，那时候他在国棉三厂上班。那是国企大厂，工人们都戴着个白帽子，看上去好像回民一样…”</p>
<p>她边说边笑着，眼睛眯着，很开心的样子。我忘了问了我当时的疑惑了。五十年代当兵，是国军呢？还是共军呢？如果是国军，那个时候怎么去大陆？如果是共军，后来怎么来了香港？</p>
<p>我说，“香港这边的福利应该挺好的。”</p>
<p>她说，“我们现在每个月都有补助，还是挺不错的，吃的，喝的，都挺好的。还有这边的小学生，补助都好几千呢，所以大陆那边有钱的都想法让孩子来这边上学。”</p>
<p>又随便聊了会。愉快的时间总是那么短暂，老太太要下车了。</p>
<p>临走，她拍了拍我的右胳膊，在地铁门口向我们挥手道别，她挥了挥手，又挥了一挥。地铁门关闭的那一刻，我知道此生我们再也不会再见了。我猜她也会这样想的吧。</p>
<p>回到深圳，时间尚早，我跟着泉泉去他们公司（招商银行）坐了会儿。他们公司刚开始使用不久的大楼，就在深交所旁边，非常气派。晚上几个人一起吃了个饭，为期两天的香港行就此结束了。</p>
<p>总体来说，香港给我的感觉很国际化。以前不出远门，总有井底之蛙之嫌，到了海外，才知道大千世界，他处别有洞天。</p>
<p>香港给我最大的想法是我要继续加大学习英语的力度，再有，以后有孩子了，得努力创造条件让他可以走出去学习、生活。现代人，需要有全球视野和国际化思维。</p>
<p>2017.10.29  22:40<br>上海 新泾北苑</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/24/2017/Firebase-教程--iOS-实时聊天/" itemprop="url">
                  Firebase-教程--iOS-实时聊天
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-24T00:00:00+08:00" content="2017-10-24">
              2017-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术博客翻译/" itemprop="url" rel="index">
                    <span itemprop="name">技术博客翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/24/2017/Firebase-教程--iOS-实时聊天/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/24/2017/Firebase-教程--iOS-实时聊天/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://www.raywenderlich.com/140836/firebase-tutorial-real-time-chat-2" target="_blank" rel="external">https://www.raywenderlich.com/140836/firebase-tutorial-real-time-chat-2</a></p>
<p>貌似市场上的主流 app 都有聊天功能，所以，我们的 app 也应当添加聊天功能啦。</p>
<p>然而，开发一个聊天工具是一个令人畏惧的工作。除了要有专门用于聊天的本地 UIKit 控件，我们还需要一个服务器来协调用户之间的消息和对话。</p>
<p>幸运的是，有一些不错的框架可以帮助我们：在<a href="https://www.firebase.google.com/" target="_blank" rel="external">Firebase</a> 的帮助下，我们可以不用写一行后端代码就可同步实时数据，而 <a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">JSQMessagesViewController</a> 则给我们提供了一个与原生消息 app 相似的消息传递 UI 。</p>
<p>在这篇 Firebase 教程中，我们将开发一个  <em>RIC</em> (Really Instant Chat) – 匿名聊天应用。如果你使用过 IRC 或者 Slack，这种 app 你应该很熟悉了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-c1fe919e57ee82fa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Real time chat app"></p>
<p>在此教程，您将学习到如下内容:</p>
<ol>
<li>使用 CocoaPods 设置 Firebase  SDK 和 JSQMessagesViewController。</li>
<li>使用 Firebase 数据库实时同步数据。</li>
<li>Firebase 匿名身份验证。</li>
<li>使用 JSQMessagesViewController 做为完整的聊天界面。</li>
<li>指示用户何时输入。</li>
<li>使用 Firebase 存储。</li>
</ol>
<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><p>下载初始工程  <a href="https://koenig-media.raywenderlich.com/uploads/2016/09/ChatChatFirebaseTutorial-start.zip" target="_blank" rel="external">the starter project here</a> 。现在，它包含一个简单的虚拟登录界面。</p>
<p>我们使用 CocoaPods 下载 Firebase SDK 和 JSQMessagesViewController。如果你还不会使用 CocoaPods ，请先学习我们这篇教程  <a href="http://www.raywenderlich.com/97014/use-cocoapods-with-swift" target="_blank" rel="external">Cocoapods with Swift tutorial</a>。</p>
<p>在项目目录下，进入终端，打开根目录下的 Podfile 文件，添加如下依赖代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Firebase/Storage&apos;</span><br><span class="line">pod &apos;Firebase/Auth&apos;</span><br><span class="line">pod &apos;Firebase/Database&apos;</span><br><span class="line">pod &apos;JSQMessagesViewController&apos;</span><br></pre></td></tr></table></figure>
<p>保存文件，命令行执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>完成依赖包下载后，在 Xcode 打开 ChatChat.xcworkspace 。在运行之前，先配置 Firebase 。</p>
<p>如果你从未使用过 Firebase，首先你需要创建一个账号。不用担心，这些是免费的。</p>
<blockquote>
<p><em>注:</em> Firebase 的操作细节，可以看这里 <a href="http://www.raywenderlich.com/109706/firebase-tutorial-getting-started" target="_blank" rel="external">Getting Started with Firebase tutorial</a>.</p>
</blockquote>
<p>#####创建 Firebase 账号 </p>
<p>登录  <a href="https://www.firebase.com/signup/" target="_blank" rel="external">the Firebase signup site</a>，创建账号，然后创建一个工程。</p>
<p>按照指示将 Firebase 添加到 iOS 应用程序，复制 <em>GoogleService-Info.plist</em> 配置文件到你的项目。它包含与应用程序的 Firebase 集成所需的配置信息。</p>
<p>build and run ，你将看到如下界面：</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/LoginScreen.jpg" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-8cddc149a138afb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Login Screen"></a></p>
<h5 id="允许匿名认证"><a href="#允许匿名认证" class="headerlink" title="允许匿名认证"></a>允许匿名认证</h5><p>Firebase允许用户通过电子邮件或社交帐户登录，但它也可以匿名地对用户进行身份验证，为用户提供唯一的标识符，而不需要了解他们任何信息。</p>
<p>要设置匿名验证，打开 Firebase 应用程序的 Dashboard，选择左侧的 Auth 选项，单击 “Sign-In” 方法，然后选择“ Anonymous”，打开 “ Enable” 按钮，然后单击 “Save”。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/EnableAnonAuth.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-787dde562d169a39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Enable anonymous auth"></a></p>
<p>像这样，我们启用了<em>超级秘密隐形模式</em> ! 好吧，虽然这只是匿名身份验证，但它仍然很酷。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/01/stealthmode.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-6da83ae75ea77c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Super secret stealth mode achieved"></a></p>
<h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><p>打开 LoginViewController.swift，添加 import UIKit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Firebase</span><br></pre></td></tr></table></figure>
<p>要登录聊天，app 需要使用 Firebase 身份验证服务进行身份验证。将以下代码添加到loginDidTouch(_:):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if nameField?.text != &quot;&quot; &#123; // 1</span><br><span class="line">  FIRAuth.auth()?.signInAnonymously(completion: &#123; (user, error) in // 2</span><br><span class="line">    if let err = error &#123; // 3</span><br><span class="line">      print(err.localizedDescription)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.performSegue(withIdentifier: &quot;LoginToChat&quot;, sender: nil) // 4</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释如下:</p>
<ol>
<li>首先，确保  name field 非空。<br>2.使用 Firebase Auth API 匿名登录，该方法带了一个方法块儿，方法块儿传递 user 和 error 信息。</li>
<li>在完成方法块里，检查是否有认证错误，如果有，终止运行。</li>
<li>最后，如果没有错误异常，进入 ChannelListViewController 页面。</li>
</ol>
<p>Build and run，输入你的名字，然后进入 app。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-a84208cd550291fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Empty channel list"></p>
<p>#####创建 Channels 列表</p>
<p>一旦用户登录了, app 导航到 ChannelListViewController 页面, 该页面展示给用户当前频道列表, 给他们提供选择创建新通道。该页面使用两个 section 的表视图。第一个 section 提供了一个表单，用户可以在其中创建一个新的通道，第二 section 列出所有已知通道。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-1f7b10766e2da484.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Channel list view"></p>
<p>本小节，我们将学到：</p>
<ol>
<li>保存数据到 Firebase 数据库</li>
<li>监听保存到数据库的新数据。</li>
</ol>
<p>在 ChannelListViewController.swift  的头部添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Firebase</span><br><span class="line"></span><br><span class="line">enum Section: Int &#123;</span><br><span class="line">  case createNewChannelSection = 0</span><br><span class="line">  case currentChannelsSection  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧随导入语句之后的 enum 中包含两个表视图 section 。</p>
<p>接下来，在类内，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Properties</span><br><span class="line">var senderDisplayName: String? // 1</span><br><span class="line">var newChannelTextField: UITextField? // 2</span><br><span class="line">private var channels: [Channel] = [] // 3</span><br></pre></td></tr></table></figure>
<p>注释如下 ：</p>
<ol>
<li>添加一个存储 sender name 的属性。</li>
<li>添加一个 text field ，稍后我们会使用它添加新的 Channels。</li>
<li>添加一个空的 Channel 对象数组，存储你的 channels。这是 starter 项目中提供的一个简单的模型类，它只包含一个名称和一个ID。</li>
</ol>
<p>接下来，我们需要设置 UITableView 来呈现新的通道和可用的通道列表。在 ChannelListViewController.swift 中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// MARK: UITableViewDataSource</span><br><span class="line">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">  return 2 // 1</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 2</span><br><span class="line">  if let currentSection: Section = Section(rawValue: section) &#123;</span><br><span class="line">    switch currentSection &#123;</span><br><span class="line">    case .createNewChannelSection:</span><br><span class="line">      return 1</span><br><span class="line">    case .currentChannelsSection:</span><br><span class="line">      return channels.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">  let reuseIdentifier = (indexPath as NSIndexPath).section == Section.createNewChannelSection.rawValue ? &quot;NewChannel&quot; : &quot;ExistingChannel&quot;</span><br><span class="line">  let cell = tableView.dequeueReusableCell(withIdentifier: reuseIdentifier, for: indexPath)</span><br><span class="line"></span><br><span class="line">  if (indexPath as NSIndexPath).section == Section.createNewChannelSection.rawValue &#123;</span><br><span class="line">    if let createNewChannelCell = cell as? CreateChannelCell &#123;</span><br><span class="line">      newChannelTextField = createNewChannelCell.newChannelNameField</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (indexPath as NSIndexPath).section == Section.currentChannelsSection.rawValue &#123;</span><br><span class="line">    cell.textLabel?.text = channels[(indexPath as NSIndexPath).row].name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于以前使用过 UITableView 的人来说，这应该是非常熟悉的，但简单地说几点:</p>
<ol>
<li>设置 Sections。请记住，第一部分将包含一个用于添加新通道的表单，第二部分将显示一个通道列表。</li>
<li>为每个部分设置行数。第一部分设置为 1，第二部分设置个数为通道的个数。</li>
<li>定义每个单元格的内容。对于第一个部分，我们将 cell 中的 text field 存储在newChannelTextField 属性中。对于第二部分，您只需将单元格的 text field 标签设置为通道名称。</li>
</ol>
<p>为了确保这一切正常工作，请在属性下面添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidAppear(_ animated: Bool) &#123;</span><br><span class="line">  super.viewDidAppear(animated)</span><br><span class="line">    </span><br><span class="line">  channels.append(Channel(id: &quot;1&quot;, name: &quot;Channel1&quot;))</span><br><span class="line">  channels.append(Channel(id: &quot;2&quot;, name: &quot;Channel2&quot;))</span><br><span class="line">  channels.append(Channel(id: &quot;3&quot;, name: &quot;Channel3&quot;))</span><br><span class="line">  self.tableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是向通道数组添加了一些虚拟通道。</p>
<p>Build and run app ; 再次登录，我们现在应该可以看到表单创建一个新的通道和三个虚拟通道:</p>
<p>太棒了! 接下来，我们需要让它与 Firebase 一起工作了。 :]</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-f5b831f7d11aa137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dummy channels"></p>
<h5 id="Firebase-数据结构"><a href="#Firebase-数据结构" class="headerlink" title="Firebase 数据结构"></a>Firebase 数据结构</h5><p>在实现实时数据同步之前，首先让我们花一会儿功夫想想数据结构。</p>
<p>Firebase database 以 NoSQL JSON 格式存储数据。</p>
<p>基本上，Firebase数据库中的所有内容都是JSON对象，而这个JSON对象的每个键都有自己的URL。</p>
<p>下面是一个说明我们的数据如何作为 JSON 对象的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;channels&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Channel 1&quot;</span><br><span class="line">    &quot;messages&quot;: &#123;</span><br><span class="line">      &quot;1&quot;: &#123; </span><br><span class="line">        &quot;text&quot;: &quot;Hey person!&quot;, </span><br><span class="line">        &quot;senderName&quot;: &quot;Alice&quot;</span><br><span class="line">        &quot;senderId&quot;: &quot;foo&quot; </span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;2&quot;: &#123;</span><br><span class="line">        &quot;text&quot;: &quot;Yo!&quot;,</span><br><span class="line">        &quot;senderName&quot;: &quot;Bob&quot;</span><br><span class="line">        &quot;senderId&quot;: &quot;bar&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Firebase 数据库支持非规范化的数据结构，因此可以为每个消息项包含 senderId。一个非规范化的数据结构意味着我们将复制大量的数据，但好处是可以更快的检索数据。</p>
<h5 id="实时-Channel-同步"><a href="#实时-Channel-同步" class="headerlink" title="实时 Channel  同步"></a>实时 Channel  同步</h5><p>首先，删除上面添加的viewDidAppear(_:)代码，然后在其他以下属性中添加以下属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private lazy var channelRef: FIRDatabaseReference = FIRDatabase.database().reference().child(&quot;channels&quot;)</span><br><span class="line">private var channelRefHandle: FIRDatabaseHandle?</span><br></pre></td></tr></table></figure>
<p>channelRef 将用于存储对数据库中通道列表的引用;channelRefHandle 将为引用保存一个句柄，以便以后可以删除它。</p>
<p>接下来，我们需要查询Firebase数据库，并得到一个在我们的表视图中显示的通道列表。添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Firebase related methods</span><br><span class="line">private func observeChannels() &#123;</span><br><span class="line">  // Use the observe method to listen for new</span><br><span class="line">  // channels being written to the Firebase DB</span><br><span class="line">  channelRefHandle = channelRef.observe(.childAdded, with: &#123; (snapshot) -&gt; Void in // 1</span><br><span class="line">    let channelData = snapshot.value as! Dictionary&lt;String, AnyObject&gt; // 2</span><br><span class="line">    let id = snapshot.key</span><br><span class="line">    if let name = channelData[&quot;name&quot;] as! String!, name.characters.count &gt; 0 &#123; // 3</span><br><span class="line">      self.channels.append(Channel(id: id, name: name))</span><br><span class="line">      self.tableView.reloadData()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      print(&quot;Error! Could not decode channel data&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ol>
<li>我们在通道引用上调用 observe:with: 方法，将句柄存储到引用。每当在数据库中添加新的通道时，就调用 completion block 。</li>
<li>completion 后接收到一个 FIRDataSnapshot (存储在快照中)，其中包含数据和其它有用的方法。</li>
<li>我们将数据从快照中提取出来，如果成功，创建一个通道模型并将其添加到我们的通道数组中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MARK: View Lifecycle</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  title = &quot;RW RIC&quot;</span><br><span class="line">  observeChannels()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">deinit &#123;</span><br><span class="line">  if let refHandle = channelRefHandle &#123;</span><br><span class="line">    channelRef.removeObserver(withHandle: refHandle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将在 view controller 加载时调用新的 observeChannels() 方法。当 view controller 通过检查 channelRefHandle 是否设置并调用    removeObserver(withHandle:) 来判断是否结束生命周期时，我们同时停止观察数据库更改。</p>
<p>在看到从 Firebase 中提取出的通道列表之前，还有一件事需要做: 提供一种方法来创建通道! 在故事板中已经设置了 IBAction，所以只需向我们的类添加以下代码就好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// MARK :Actions </span><br><span class="line">@IBAction func createChannel(_ sender: AnyObject) &#123;</span><br><span class="line">  if let name = newChannelTextField?.text &#123; // 1</span><br><span class="line">    let newChannelRef = channelRef.childByAutoId() // 2</span><br><span class="line">    let channelItem = [ // 3</span><br><span class="line">      &quot;name&quot;: name</span><br><span class="line">    ]</span><br><span class="line">    newChannelRef.setValue(channelItem) // 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是详细解释：</p>
<ol>
<li>首先检查 text field 是否拥有一个 channel name.</li>
<li>使用 childByAutoId() 唯一标志 key 创建一个通道引用。</li>
<li>创建一个字典，以此保存通道的数据。[String: AnyObject] 是类似 JSON 的对象。</li>
<li>最后，在这个新的通道上设置名称，它将自动保存到Firebase !</li>
</ol>
<p>Build and run 我们的 app ,创建一些 channels。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-a3c352bdcd94b479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Create channels"></p>
<p>所有内容都应该按照预期运行，但我们还没有实现当用户点击时可以访问其中一个通道。让我们添加以下代码来解决这个问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// MARK: UITableViewDelegate</span><br><span class="line">override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;</span><br><span class="line">  if indexPath.section == Section.currentChannelsSection.rawValue &#123;</span><br><span class="line">    let channel = channels[(indexPath as NSIndexPath).row]</span><br><span class="line">    self.performSegue(withIdentifier: &quot;ShowChannel&quot;, sender: channel)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，我们应该很熟悉了。当用户点击通道 cell 时，它会触发 ShowChannel segue。</p>
<h5 id="创建聊天界面"><a href="#创建聊天界面" class="headerlink" title="创建聊天界面"></a>创建聊天界面</h5><p>JSQMessagesViewController 是一个 UICollectionViewController 定制聊天控制类,所以我们不需要再创建自己的了! </p>
<p>这部分教程，我们将关注四点：</p>
<ol>
<li>创建消息数据。</li>
<li>创建消息泡沫。</li>
<li>删除头像支持。</li>
<li>改变 UICollectionViewCell 的 文字颜色。</li>
</ol>
<p>几乎所有需要做的事情都需要覆盖方法。JSQMessagesViewController 采用JSQMessagesCollectionViewDataSource 协议,所以我们只需要覆盖默认的实现方法就好了。</p>
<blockquote>
<p>注意:有关 JSQMessagesCollectionViewDataSource的更多信息, 请查看这里的 <a href="http://cocoadocs.org/docsets/JSQMessagesViewController/7.3.4/Protocols/JSQMessagesCollectionViewDataSource.html" target="_blank" rel="external">Cocoa 文档</a>。</p>
</blockquote>
<p>打开 ChatViewController.swift ，添加如下引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Firebase</span><br><span class="line">import JSQMessagesViewController</span><br></pre></td></tr></table></figure>
<p>将继承类 UIViewController 改为 JSQMessagesViewController：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final class ChatViewController: JSQMessagesViewController &#123;</span><br></pre></td></tr></table></figure></p>
<p>在 ChatViewController 头部，定义如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channelRef: FIRDatabaseReference?</span><br><span class="line">var channel: Channel? &#123;</span><br><span class="line">  didSet &#123;</span><br><span class="line">    title = channel?.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然 ChatViewController 继承自JSQMessagesViewController , 我们需要设置 senderId 和 senderDisplayName 的初始值，以使 app 可以唯一标识消息的发送者——即使它不知道那个人具体是谁。</p>
<p>这些需要在 view controller 首次实例化时设置。最好的设置时刻是当 segue 即将 prepare 时。回到ChannelListViewController, 添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Navigation</span><br><span class="line">override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">  super.prepare(for: segue, sender: sender)</span><br><span class="line">  </span><br><span class="line">  if let channel = sender as? Channel &#123;</span><br><span class="line">    let chatVc = segue.destination as! ChatViewController</span><br><span class="line">  </span><br><span class="line">    chatVc.senderDisplayName = senderDisplayName</span><br><span class="line">    chatVc.channel = channel</span><br><span class="line">    chatVc.channelRef = channelRef.child(channel.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将在执行 segue 之前创建的 ChatViewController 上设置属性。</p>
<p>获得 senderDisplayName 的最佳位置是当用户登录时输入他们的名字。</p>
<p>在 LoginViewController.swift，添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Navigation</span><br><span class="line">override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">  super.prepare(for: segue, sender: sender)</span><br><span class="line">  let navVc = segue.destination as! UINavigationController // 1</span><br><span class="line">  let channelVc = navVc.viewControllers.first as! ChannelListViewController // 2</span><br><span class="line">   </span><br><span class="line">  channelVc.senderDisplayName = nameField?.text // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<ol>
<li>从 segue 获取目标视图控制器并将其转换为 UINavigationController。</li>
<li>强制转换 UINavigationController 的第一个view controller 为 ChannelListViewController。</li>
<li>设置 ChannelListViewController 的senderDisplayName 为 nameField 中提供的用户名。</li>
</ol>
<p>返回 ChatViewController.swift，在 viewDidLoad() 方法最下方添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.senderId = FIRAuth.auth()?.currentUser?.uid</span><br></pre></td></tr></table></figure>
<p>这将基于已登录的 Firebase 用户设置 senderId。</p>
<p>Build and run 我们的 app 并导航到一个 channel 页面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-776c63c5ee902e62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Empty Channel"></p>
<p>通过简单地继承 JSQMessagesViewController，我们得到一个完整的聊天界面。:]</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-204b29589556dd27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fine chat app"></p>
<h5 id="设置-Data-Source-和-Delegate"><a href="#设置-Data-Source-和-Delegate" class="headerlink" title="设置  Data Source 和 Delegate"></a>设置  Data Source 和 Delegate</h5><p>现在我们已经看到了新的很棒的聊天 UI，我们可能想要开始显示消息了。但在这么做之前，我们必须注意一些事情。</p>
<p>要显示消息，我们需要一个数据源来提供符合 JSQMessageData 协议的对象，我们还需要实现一些委托方法。虽然我们可以创建符合 JSQMessageData 协议的类，但我们将使用已经提供的 JSQMessage 类。</p>
<p>在 ChatViewController 顶部，添加如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var messages = [JSQMessage]()</span><br></pre></td></tr></table></figure>
<p>messages 是应用程序中存储 JSQMessage 各种实例的数组。</p>
<p>添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: JSQMessagesCollectionView!, messageDataForItemAt indexPath: IndexPath!) -&gt; JSQMessageData! &#123;</span><br><span class="line">  return messages[indexPath.item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">  return messages.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述两种委托方法，我们并不陌生。第一个类似于 collectionView(_:cellForItemAtIndexPath:)，只是管理的对象是 message data。第二种是在每个 section 中返回messages 数量的标准方法;</p>
<h5 id="消息气泡颜色"><a href="#消息气泡颜色" class="headerlink" title="消息气泡颜色"></a>消息气泡颜色</h5><p>在  collection view 中显示的消息只是文本覆盖的图像。有两种类型的消息:传出和传入。传出的消息会显示在右边，传入的消息显示在左边。</p>
<p>在 ChatViewController 中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private func setupOutgoingBubble() -&gt; JSQMessagesBubbleImage &#123;</span><br><span class="line">  let bubbleImageFactory = JSQMessagesBubbleImageFactory()</span><br><span class="line">  return bubbleImageFactory!.outgoingMessagesBubbleImage(with: UIColor.jsq_messageBubbleBlue())</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">private func setupIncomingBubble() -&gt; JSQMessagesBubbleImage &#123;</span><br><span class="line">  let bubbleImageFactory = JSQMessagesBubbleImageFactory()</span><br><span class="line">  return bubbleImageFactory!.incomingMessagesBubbleImage(with: UIColor.jsq_messageBubbleLightGray())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在头部添加如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazy var outgoingBubbleImageView: JSQMessagesBubbleImage = self.setupOutgoingBubble()</span><br><span class="line">lazy var incomingBubbleImageView: JSQMessagesBubbleImage = self.setupIncomingBubble()</span><br></pre></td></tr></table></figure>
<p>JSQMessagesBubbleImageFactory 有创建聊天泡泡的图片方法,。JSQMessagesViewController 甚至还有一个类别提供创建消息泡沫的颜色。</p>
<p>使用 outgoingMessagesBubbleImage (:with) 和incomingMessagesBubbleImage(: with)方法,我们可以创建输入输出图像。这样，我们就有了创建传出和传入消息气泡所需的图像视图了!</p>
<p>先别太兴奋了，我们还需要实现消息气泡的委托方法。</p>
<p>#####设置气泡图像 </p>
<p>为每个 message 设置 colored bubble imag ，我们需要重载被collectionView(_:messageBubbleImageDataForItemAt:)调用的 JSQMessagesCollectionViewDataSource 方法。</p>
<p>这要求数据源提供消息气泡图像数据，该数据对应于collectionView 中的 indexPath 中的 message 项。</p>
<p>在 ChatViewController 添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: JSQMessagesCollectionView!, messageBubbleImageDataForItemAt indexPath: IndexPath!) -&gt; JSQMessageBubbleImageDataSource! &#123;</span><br><span class="line">  let message = messages[indexPath.item] // 1</span><br><span class="line">  if message.senderId == senderId &#123; // 2</span><br><span class="line">    return outgoingBubbleImageView</span><br><span class="line">  &#125; else &#123; // 3</span><br><span class="line">    return incomingBubbleImageView</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码注释:</p>
<ol>
<li>在这里检索消息。</li>
<li>如果消息是由本地用户发送的，则返回 outgoing image view。</li>
<li>相反，则返回 incoming image view.</li>
</ol>
<h5 id="移除头像"><a href="#移除头像" class="headerlink" title="移除头像"></a>移除头像</h5><p>JSQMessagesViewController 提供头像，但是在匿名 RIC app 中我们不需要或者不想使用头像。</p>
<p>在 ChatViewController 添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: JSQMessagesCollectionView!, avatarImageDataForItemAt indexPath: IndexPath!) -&gt; JSQMessageAvatarImageDataSource! &#123;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了移除 avatar image, 在每个  message’s avatar display 返回 nil 。</p>
<p>最后，在 viewDidLoad() 添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// No avatars</span><br><span class="line">collectionView!.collectionViewLayout.incomingAvatarViewSize = CGSize.zero</span><br><span class="line">collectionView!.collectionViewLayout.outgoingAvatarViewSize = CGSize.zero</span><br></pre></td></tr></table></figure>
<p>这将告诉布局，当没有 avatars 时，avatar 大小为 CGSize.zero。</p>
<p>检查 app 构建，我们可以导航到我们的一个频道;</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-5d347b3550343216.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Empty channel"></p>
<p>是时候开始对话并添加一些信息了!</p>
<h5 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h5><p>在 ChatViewController 中创建如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private func addMessage(withId id: String, name: String, text: String) &#123;</span><br><span class="line">  if let message = JSQMessage(senderId: id, displayName: name, text: text) &#123;</span><br><span class="line">    messages.append(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法创建了一个 JSQMessage，并添加到 messages 数据源中。</p>
<p>在 viewDidAppear(_:) 添加硬编码消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// messages from someone else</span><br><span class="line">addMessage(withId: &quot;foo&quot;, name: &quot;Mr.Bolt&quot;, text: &quot;I am so fast!&quot;)</span><br><span class="line">// messages sent from local sender</span><br><span class="line">addMessage(withId: senderId, name: &quot;Me&quot;, text: &quot;I bet I can run faster than you!&quot;)</span><br><span class="line">addMessage(withId: senderId, name: &quot;Me&quot;, text: &quot;I like to run!&quot;)</span><br><span class="line">// animates the receiving of a new message on the view</span><br><span class="line">finishReceivingMessage()</span><br></pre></td></tr></table></figure>
<p>Build and run，我们将看到如下效果：</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/FakeMessageData.jpg" target="_blank" rel="external"></a></p>
<p>恩，文字读起来有点不爽，它应该显示黑色的。</p>
<h4 id="消息气泡文字"><a href="#消息气泡文字" class="headerlink" title="消息气泡文字"></a>消息气泡文字</h4><p>现在我们知道，如果想在 JSQMessagesViewController 做几乎所有事情,我们只需要覆盖一个方法。要设置文本颜色，请使用老式的collectionView(_:cellForItemAt:)。</p>
<p>在 ChatViewController 中添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">  let cell = super.collectionView(collectionView, cellForItemAt: indexPath) as! JSQMessagesCollectionViewCell</span><br><span class="line">  let message = messages[indexPath.item]</span><br><span class="line">  </span><br><span class="line">  if message.senderId == senderId &#123;</span><br><span class="line">    cell.textView?.textColor = UIColor.white</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cell.textView?.textColor = UIColor.black</span><br><span class="line">  &#125;</span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息是由本地用户发送的，设置文本颜色为白色。如果不是本地用户发送的，设置文本颜色为黑色。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/08/FakeMessageDataEasyToRead.jpg" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-0a5bd0a189d15586.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Incoming messages"></a></p>
<p>这是一个很不错的聊天 app! 是时候让它与 Firebase 一起工作了。</p>
<h4 id="Sending-Messages"><a href="#Sending-Messages" class="headerlink" title="Sending Messages"></a>Sending Messages</h4><p>在  ChatViewController.swift 中添加如下属性：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private lazy var messageRef: FIRDatabaseReference = self.channelRef!.child(&quot;messages&quot;)</span><br><span class="line">private var newMessageRefHandle: FIRDatabaseHandle?</span><br></pre></td></tr></table></figure>
<p>这和我们在 ChannelListViewController 中添加的 channelRef、 channelRefHandle 属性相似，我们应该很熟悉了。</p>
<p>接下来，删除  ChatViewController 中的 viewDidAppear(_:) ，移除  stub test messages。</p>
<p>然后，重写以下方法，使 “发送” 按钮将消息保存到 Firebase 数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override func didPressSend(_ button: UIButton!, withMessageText text: String!, senderId: String!, senderDisplayName: String!, date: Date!) &#123;</span><br><span class="line">  let itemRef = messageRef.childByAutoId() // 1</span><br><span class="line">  let messageItem = [ // 2 </span><br><span class="line">    &quot;senderId&quot;: senderId!,</span><br><span class="line">    &quot;senderName&quot;: senderDisplayName!,</span><br><span class="line">    &quot;text&quot;: text!,</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  itemRef.setValue(messageItem) // 3</span><br><span class="line">  </span><br><span class="line">  JSQSystemSoundPlayer.jsq_playMessageSentSound() // 4</span><br><span class="line">  </span><br><span class="line">  finishSendingMessage() // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>使用 childByAutoId()，创建一个带有惟一键的子引用。</li>
<li>然后创建一个字典来存储消息。</li>
<li>接下来，保存新子位置上的值。</li>
<li>然后播放常规的 “消息发送”  声音。</li>
<li>最后，完成 “发送” 操作并将输入框重置为空。</li>
</ol>
<p>Build and run; 打开 Firebase 应用程序指示板并单击 Data 选项卡。在应用程序中发送一条消息，我们就可以看到实时显示在仪表板上的消息了:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-6966090a573224fc.gif?imageMogr2/auto-orient/strip" alt="Sending a message"></p>
<p>High five ! 我们已经可以像专业人员一样将消息保存到 Firebase 数据库了。现在消息还不会出现在屏幕上，接下来我们将处理它。</p>
<h5 id="同步-Data-Source"><a href="#同步-Data-Source" class="headerlink" title="同步 Data Source"></a>同步 Data Source</h5><p>在 ChatViewController 中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private func observeMessages() &#123;</span><br><span class="line"> messageRef = channelRef!.child(&quot;messages&quot;)</span><br><span class="line"> // 1.</span><br><span class="line"> let messageQuery = messageRef.queryLimited(toLast:25)</span><br><span class="line"> </span><br><span class="line"> // 2. We can use the observe method to listen for new</span><br><span class="line"> // messages being written to the Firebase DB</span><br><span class="line"> newMessageRefHandle = messageQuery.observe(.childAdded, with: &#123; (snapshot) -&gt; Void in</span><br><span class="line">   // 3</span><br><span class="line">   let messageData = snapshot.value as! Dictionary&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">   if let id = messageData[&quot;senderId&quot;] as String!, let name = messageData[&quot;senderName&quot;] as String!, let text = messageData[&quot;text&quot;] as String!, text.characters.count &gt; 0 &#123;</span><br><span class="line">     // 4</span><br><span class="line">     self.addMessage(withId: id, name: name, text: text)</span><br><span class="line">     </span><br><span class="line">     // 5</span><br><span class="line">     self.finishReceivingMessage()</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     print(&quot;Error! Could not decode message data&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下注解：</p>
<ol>
<li>首先创建一个查询，将同步限制到最后 25 条消息。</li>
<li>使用 .ChildAdded 观察已经添加到和即将添加到 messages 位置每个子 item。</li>
<li>从 snapshot 中提取messageData。</li>
<li>使用 addMessage(withId:name:text) 方法添加新消息到数据源。</li>
<li>通知 JSQMessagesViewController，已经接收了消息。 </li>
</ol>
<p>接下来，在 viewDidLoad() 中调用方法： observeMessages()。</p>
<p>Build and run，我们将看到我们前面输入和现在输入的所有消息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-402d03270957ef56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Messages from firebase"></p>
<p>恭喜!我们已经有一个实时聊天应用了! 现在是做一些更高级的事情的时候了，比如在用户输入的时候检测。</p>
<h5 id="检测用户何时在输入"><a href="#检测用户何时在输入" class="headerlink" title="检测用户何时在输入"></a>检测用户何时在输入</h5><p>这款应用程序最酷的功能之一就是看到 “用户正在输入” 的指示器。当小气泡弹出时，你知道另一个用户在键盘上打字。这个指标非常重要，因为它可以避免我们发送那些尴尬的 “你还在吗?” 消息。</p>
<p>检测打字有很多方法，但 textViewDidChange(_:) 是一个很好的检查时机。将以下内容添加到ChatViewController的底部:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func textViewDidChange(_ textView: UITextView) &#123;</span><br><span class="line">  super.textViewDidChange(textView)</span><br><span class="line">  // If the text is not empty, the user is typing</span><br><span class="line">  print(textView.text != &quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要确定用户是否在输入，请检查 textview . text 的值。如果这个值不是空字符串，那么您就知道用户已经键入了一些东西。</p>
<p>通过 Firebase ，  当用户输入时我们可以更新 Firebase 数据库。然后，为了响应数据库更新这个指示，我们可以显示 “用户正在输入” 指示器。</p>
<p>为了实现目的，在 ChatViewController 中添加如下属性：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private lazy var userIsTypingRef: FIRDatabaseReference = </span><br><span class="line">  self.channelRef!.child(&quot;typingIndicator&quot;).child(self.senderId) // 1</span><br><span class="line">private var localTyping = false // 2</span><br><span class="line">var isTyping: Bool &#123;</span><br><span class="line">  get &#123;</span><br><span class="line">    return localTyping</span><br><span class="line">  &#125;</span><br><span class="line">  set &#123;</span><br><span class="line">    // 3</span><br><span class="line">    localTyping = newValue</span><br><span class="line">    userIsTypingRef.setValue(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是我们需要了解的这些特性:</p>
<ol>
<li>创建一个用于跟踪本地用户是否正在输入的 Firebase 引用。</li>
<li>新增私有属性，标记本地用户是否在输入。</li>
<li>每次更改时，使用计算属性更新 localTyping 和 userIsTypingRef。</li>
</ol>
<p>现在，添加如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private func observeTyping() &#123;</span><br><span class="line">  let typingIndicatorRef = channelRef!.child(&quot;typingIndicator&quot;)</span><br><span class="line">  userIsTypingRef = typingIndicatorRef.child(senderId)</span><br><span class="line">  userIsTypingRef.onDisconnectRemoveValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法创建一个名为 typingIndicator 的通道的子引用，它是我们更新用户输入状态的地方。我们不希望这些数据在用户注销之后仍然逗留，因此我们可以在用户使用后删除它 onDisconnectRemoveValue()。</p>
<p>添加以下内容调用新方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidAppear(_ animated: Bool) &#123;</span><br><span class="line">  super.viewDidAppear(animated)</span><br><span class="line">  observeTyping()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换 textViewDidChange(_:) 中的 print(textView.text != “”) ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isTyping = textView.text != &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>这只是在用户输入时设置 isTyping。</p>
<p>最后，在 didPressSend(_:withMessageText:senderId:senderDisplayName:date:): 后面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isTyping = false</span><br></pre></td></tr></table></figure></p>
<p>当按下 Send 按钮时，这将重置输入指示器。</p>
<p>Build and run，打开Firebase应用程序仪表板查看数据。当我们键入消息时，我们应该可以看到为用户提供的类型指示器记录更新:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-157a7ff101cd9e6a.gif?imageMogr2/auto-orient/strip" alt="Typing indicator"></p>
<p>我们现在已经知道什么时候用户在输入了，接下来是显示指示器的时候了。</p>
<h4 id="查询正在输入的用户"><a href="#查询正在输入的用户" class="headerlink" title="查询正在输入的用户"></a>查询正在输入的用户</h4><p>“用户正在输入”  指示符应该在除本地用户外任何用户键入时显示，因为本地用户在键入时自己已经知道啦。</p>
<p>使用 Firebase query ，我们可以检索当前正在键入的所有用户。在 ChatViewController  中添加如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private lazy var usersTypingQuery: FIRDatabaseQuery = </span><br><span class="line">  self.channelRef!.child(&quot;typingIndicator&quot;).queryOrderedByValue().queryEqual(toValue: true)</span><br></pre></td></tr></table></figure></p>
<p>这个属性保存了一个 FIRDatabaseQuery，它就像一个 Firebase 引用，但它是有序的。通过检索所有正在输入的用户来初始化查询。这基本上是说，“嘿，Firebase，查询关键字 / typing 指示器，然后给我所有值为 true 的用户。”</p>
<p>接下来，在  observeTyping() 添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">usersTypingQuery.observe(.value) &#123; (data: FIRDataSnapshot) in</span><br><span class="line">  // 2 You&apos;re the only one typing, don&apos;t show the indicator</span><br><span class="line">  if data.childrenCount == 1 &amp;&amp; self.isTyping &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 3 Are there others typing?</span><br><span class="line">  self.showTypingIndicator = data.childrenCount &gt; 0</span><br><span class="line">  self.scrollToBottom(animated: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<ol>
<li>我们使用 .value 监听状态，当其值改变时，该 ompletion block  将被调用。</li>
<li>我们需要知道在查询中有多少用户，如果仅仅只有本地用户，不显示指示器。</li>
<li>如果有用户，再设置指示器显示。调用 scrolltobottom 动画以确保显示指示器。</li>
</ol>
<p>在 build and run 之前，拿起一个物理 iOS 设备，测试这种情况需要两个设备。一个用户使用模拟器，另一个用户使用真机。</p>
<p>现在，同时 build and run 模拟器和真机，当一个用户输入时，另外用户可以看到指示器出现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-9829fac8efcfc977.gif?imageMogr2/auto-orient/strip" alt="Multi-user typing indicator"></p>
<p>现在我们有了一个打字指示器，但我们还缺少一个现代通讯应用的一大特色功能——发送图片!</p>
<h5 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h5><p>要发送图像，我们将遵循与发送文本相同的原则，其中有一个关键区别: 我们将使用 Firebase 存储，而不是直接将图像数据存储在消息中，这更适合存储音频、视频或图像等大型文件。</p>
<p>在  ChatViewController.swift 中添加 Photos ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Photos</span><br></pre></td></tr></table></figure></p>
<p>接下来，添加如下属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazy var storageRef: FIRStorageReference = FIRStorage.storage().reference(forURL: &quot;YOUR_URL_HERE&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这是一个 Firebase 存储引用，概念上类似于我们已经看到的 Firebase 数据库引用，但是对于存储对象来说，用你的 Firebase 应用程序 URL 替换YOUR_URL_HERE，我们可以在你的应用程序控制台中点击存储。<br><img src="http://upload-images.jianshu.io/upload_images/130752-189474f3b3774ad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Firebase console storage"></p>
<p>发送照片信息需要一点点的 smoke 和 mirrors ，而不是在这段时间阻塞用户界面，这会让你的应用感觉很慢。保存照片到Firebase 存储返回一个URL，这可能需要几秒钟——如果网络连接很差的话，可能需要更长的时间。我们会用一个假的URL发送照片信息，并在照片保存后更新消息。</p>
<p>添加如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private let imageURLNotSetKey = &quot;NOTSET&quot;</span><br></pre></td></tr></table></figure></p>
<p>并添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func sendPhotoMessage() -&gt; String? &#123;</span><br><span class="line">  let itemRef = messageRef.childByAutoId()</span><br><span class="line"></span><br><span class="line">  let messageItem = [</span><br><span class="line">    &quot;photoURL&quot;: imageURLNotSetKey,</span><br><span class="line">    &quot;senderId&quot;: senderId!,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  itemRef.setValue(messageItem)</span><br><span class="line"></span><br><span class="line">  JSQSystemSoundPlayer.jsq_playMessageSentSound()</span><br><span class="line"></span><br><span class="line">  finishSendingMessage()</span><br><span class="line">  return itemRef.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这很像我们之前实现的 didPressSend(_:withMessageText:senderId:senderDisplayName:date:) 方法。</p>
<p>现在，我们需要能够在获取映像的 Firebase 存储 URL之后更新消息。添加以下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func setImageURL(_ url: String, forPhotoMessageWithKey key: String) &#123;</span><br><span class="line">  let itemRef = messageRef.child(key)</span><br><span class="line">  itemRef.updateChildValues([&quot;photoURL&quot;: url])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要允许用户选择要发送的图像。幸运的是 JSQMessagesViewController 已经包含添加一个图像到我们消息的 UI ,所以我们只需要实现对应的方法处理点击就好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override func didPressAccessoryButton(_ sender: UIButton) &#123;</span><br><span class="line">  let picker = UIImagePickerController()</span><br><span class="line">  picker.delegate = self</span><br><span class="line">  if (UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceType.camera)) &#123;</span><br><span class="line">    picker.sourceType = UIImagePickerControllerSourceType.camera</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    picker.sourceType = UIImagePickerControllerSourceType.photoLibrary</span><br><span class="line">  &#125;</span><br><span class="line">     </span><br><span class="line">  present(picker, animated: true, completion:nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，如果设备支持拍照，将弹出摄像机，如果不支持，会弹出相册。</p>
<p>接下来,当用户选择图像，我们需要实现 UIImagePickerControllerDelegate方法来处理。将以下内容添加到文件的底部(在最后一个关闭括号之后):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// MARK: Image Picker Delegate</span><br><span class="line">extension ChatViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123;</span><br><span class="line">  func imagePickerController(_ picker: UIImagePickerController, </span><br><span class="line">    didFinishPickingMediaWithInfo info: [String : Any]) &#123;</span><br><span class="line">      </span><br><span class="line">    picker.dismiss(animated: true, completion:nil)</span><br><span class="line"></span><br><span class="line">    // 1</span><br><span class="line">    if let photoReferenceUrl = info[UIImagePickerControllerReferenceURL] as? URL &#123;</span><br><span class="line">      // Handle picking a Photo from the Photo Library</span><br><span class="line">      // 2</span><br><span class="line">      let assets = PHAsset.fetchAssets(withALAssetURLs: [photoReferenceUrl], options: nil)</span><br><span class="line">      let asset = assets.firstObject</span><br><span class="line">      </span><br><span class="line">      // 3</span><br><span class="line">      if let key = sendPhotoMessage() &#123;</span><br><span class="line">        // 4 </span><br><span class="line">        asset?.requestContentEditingInput(with: nil, completionHandler: &#123; (contentEditingInput, info) in</span><br><span class="line">          let imageFileURL = contentEditingInput?.fullSizeImageURL</span><br><span class="line">          </span><br><span class="line">          // 5</span><br><span class="line">          let path = &quot;\(FIRAuth.auth()?.currentUser?.uid)/\(Int(Date.timeIntervalSinceReferenceDate * 1000))/\(photoReferenceUrl.lastPathComponent)&quot;</span><br><span class="line"></span><br><span class="line">          // 6</span><br><span class="line">          self.storageRef.child(path).putFile(imageFileURL!, metadata: nil) &#123; (metadata, error) in</span><br><span class="line">            if let error = error &#123;</span><br><span class="line">              print(&quot;Error uploading photo: \(error.localizedDescription)&quot;)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">            // 7</span><br><span class="line">            self.setImageURL(self.storageRef.child((metadata?.path)!).description, forPhotoMessageWithKey: key)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Handle picking a Photo from the Camera - TODO</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123;</span><br><span class="line">    picker.dismiss(animated: true, completion:nil)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>首先，从 info dictionary 获取图像。</li>
<li>调用  sendPhotoMessage() 方法，保存图像 URL 到 Firebase 数据库。</li>
<li>接下来，我们将得到照片的 JPEG 表示，准备发送到 Firebase 存储。</li>
<li>如前所述，根据用户的惟一 id 和当前时间创建一个独特的 URL。</li>
<li>创建一个 FIRStorageMetadata 对象并将元数据设置为 image / jpeg。</li>
<li>然后保存图像到 Firebase 数据库。</li>
<li>图像被保存后，我们将再次调用 setImageURL() 方法。</li>
</ol>
<p>几近完美! 现在我们已经建立了可以将图像数据保存到 Firebase 并将 URL 保存到消息数据存储中的应用程序，但我们还没有更新应用程序来显示这些照片。接下来我们来解决这个问题。</p>
<h4 id="展示图像"><a href="#展示图像" class="headerlink" title="展示图像"></a>展示图像</h4><p>首先，在 ChatViewController 中添加属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var photoMessageMap = [String: JSQPhotoMediaItem]()</span><br></pre></td></tr></table></figure>
<p>它包含一个 jsqphotomediaitem 数组。</p>
<p>现在，我们需要为 addMessage (withId:name:text:) 创建一个兄弟方法。添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private func addPhotoMessage(withId id: String, key: String, mediaItem: JSQPhotoMediaItem) &#123;</span><br><span class="line">  if let message = JSQMessage(senderId: id, displayName: &quot;&quot;, media: mediaItem) &#123;</span><br><span class="line">    messages.append(message)</span><br><span class="line"></span><br><span class="line">    if (mediaItem.image == nil) &#123;</span><br><span class="line">      photoMessageMap[key] = mediaItem</span><br><span class="line">    &#125;</span><br><span class="line">    collectionView.reloadData()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果图像键尚未设置，则将 JSQPhotoMediaItem 存储在新属性中。这允许我们在稍后设置图像时检索并更新消息。</p>
<p>我们还需要能够从 Firebase 数据库获取图像数据，以便在UI中显示它。添加以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private func fetchImageDataAtURL(_ photoURL: String, forMediaItem mediaItem: JSQPhotoMediaItem, clearsPhotoMessageMapOnSuccessForKey key: String?) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let storageRef = FIRStorage.storage().reference(forURL: photoURL)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  storageRef.data(withMaxSize: INT64_MAX)&#123; (data, error) in</span><br><span class="line">    if let error = error &#123;</span><br><span class="line">      print(&quot;Error downloading image data: \(error)&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    storageRef.metadata(completion: &#123; (metadata, metadataErr) in</span><br><span class="line">      if let error = metadataErr &#123;</span><br><span class="line">        print(&quot;Error downloading metadata: \(error)&quot;)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 4</span><br><span class="line">      if (metadata?.contentType == &quot;image/gif&quot;) &#123;</span><br><span class="line">        mediaItem.image = UIImage.gifWithData(data!)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        mediaItem.image = UIImage.init(data: data!)</span><br><span class="line">      &#125;</span><br><span class="line">      self.collectionView.reloadData()</span><br><span class="line">      </span><br><span class="line">      // 5</span><br><span class="line">      guard key != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      self.photoMessageMap.removeValue(forKey: key!)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>获取存储映像的引用。</li>
<li>从存储中获取对象。</li>
<li>从存储中获取图像元数据。</li>
<li>如果元数据显示图像是 GIF，我们需要使用 UIImage 类别，它通过 SwiftGifOrigin Cocapod 被拉进来。这是需要的，因为 UIImage 不处理 GIF 图像。否则我们只需要用普通的 UIImage 就可以了。</li>
<li>最后，我们从 photoMessageMap 中删除键，现在我们已经获取了图像数据。</li>
</ol>
<p>最后，我们需要更新 observeMessages()。在 if 语句中，但在 else 条件之前，添加以下测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if let id = messageData[&quot;senderId&quot;] as String!,</span><br><span class="line">        let photoURL = messageData[&quot;photoURL&quot;] as String! &#123; // 1</span><br><span class="line">  // 2</span><br><span class="line">  if let mediaItem = JSQPhotoMediaItem(maskAsOutgoing: id == self.senderId) &#123;</span><br><span class="line">    // 3</span><br><span class="line">    self.addPhotoMessage(withId: id, key: snapshot.key, mediaItem: mediaItem)</span><br><span class="line">    // 4</span><br><span class="line">    if photoURL.hasPrefix(&quot;gs://&quot;) &#123;</span><br><span class="line">      self.fetchImageDataAtURL(photoURL, forMediaItem: mediaItem, clearsPhotoMessageMapOnSuccessForKey: nil)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们逐行解释：</p>
<ol>
<li>首先，检查你是否有一个photoURL集。</li>
<li>如果可以，创建一个新的 JSQPhotoMediaItem。这个对象封装了消息中的富媒体——正是你所需要的!</li>
<li>调用 addPhotoMessage 方法。</li>
<li>最后，检查一下，确保 photoURL 包含一个 Firebase 存储对象的前缀。如果是，获取图像数据。</li>
</ol>
<p>现在只剩下最后一件事了，你能猜到是什么么？</p>
<p>当你在解码照片信息时，你只是在你第一次观察图像数据时才这样做。但是，你还需要观察稍后发生的消息的任何更新，比如在将图像 URL 保存到存储后更新它。</p>
<p>添加下面属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var updatedMessageRefHandle: FIRDatabaseHandle?</span><br></pre></td></tr></table></figure>
<p>在 observeMessages() 底部添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// We can also use the observer method to listen for</span><br><span class="line">// changes to existing messages.</span><br><span class="line">// We use this to be notified when a photo has been stored</span><br><span class="line">// to the Firebase Storage, so we can update the message data</span><br><span class="line">updatedMessageRefHandle = messageRef.observe(.childChanged, with: &#123; (snapshot) in</span><br><span class="line">  let key = snapshot.key</span><br><span class="line">  let messageData = snapshot.value as! Dictionary&lt;String, String&gt; // 1</span><br><span class="line">    </span><br><span class="line">  if let photoURL = messageData[&quot;photoURL&quot;] as String! &#123; // 2</span><br><span class="line">    // The photo has been updated.</span><br><span class="line">    if let mediaItem = self.photoMessageMap[key] &#123; // 3</span><br><span class="line">      self.fetchImageDataAtURL(photoURL, forMediaItem: mediaItem, clearsPhotoMessageMapOnSuccessForKey: key) // 4</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<ol>
<li>从 Firebase 快照中获取消息数据字典。</li>
<li>检查字典是否有一个 photoURL 键集。</li>
<li>如果是这样，则从缓存中提取 JSQPhotoMediaItem。</li>
<li>最后，获取图像数据并使用图像更新消息!</li>
</ol>
<p>当 ChatViewController 消失时，我们需要做的最后一件事就是整理和清理。添加以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">  if let refHandle = newMessageRefHandle &#123;</span><br><span class="line">    messageRef.removeObserver(withHandle: refHandle)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if let refHandle = updatedMessageRefHandle &#123;</span><br><span class="line">    messageRef.removeObserver(withHandle: refHandle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Build and run 应用程序; 我们就应该能够在聊天中点击小的 paperclip 图标发送照片或图片信息了。注意这些消息何时显示一个等待的小 spinner—— 当我们的应用程序保存照片数据到 Firebase 存储的时候。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-e159da58121447fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Send photos"></p>
<p>Kaboom! 我们刚刚做了一个说大也大说小也小、实时的、用户可以输入照片和 GIF 的聊天应用程序。</p>
<p>####Where to Go From Here?</p>
<p>Demo 下载地址： <a href="https://koenig-media.raywenderlich.com/uploads/2016/09/ChatChatFirebaseTutorial-finished.zip" target="_blank" rel="external">completed project</a> </p>
<p>我们现在知道 Firebase 和 JSQMessagesViewController 的基本知识，但还有很多你可以做，包括 one-to-one messaging、social authentication、头像显示等。</p>
<p>想更多了解，请查阅 <a href="https://firebase.google.com/docs/ios" target="_blank" rel="external">Firebase iOS documentation</a>.</p>
<p> – 2017.10.24<br>上海 虹桥V1</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/22/2017/姑苏、姑苏/" itemprop="url">
                  姑苏、姑苏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-22T22:39:00+08:00" content="2017-09-22">
              2017-09-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/周游天下/" itemprop="url" rel="index">
                    <span itemprop="name">周游天下</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/09/22/2017/姑苏、姑苏/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/22/2017/姑苏、姑苏/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>君到姑苏见，人家尽枕河。古宫闲地少，水港小桥多。<br>夜市卖菱藕，春船载绮罗。遥知未眠月，乡思在渔歌。</p>
</blockquote>
<p>时间过得真快，距离去苏州已经两周了。</p>
<p>最近一段时间工作有点忙碌，每天任务都被安排得满满的，一直想抽出点时间写这篇游记，总是找不到足够长的时间段，而碎片时间又不适合写字，因为思路总会被打乱。一拖再拖下，一直到现在才写。</p>
<p>工作忙点是好事，每天都有很多事情做，这样会比较充实，可是一旦快节奏生活惯了，你会感觉时间过得太快，快到让你错觉自己的生命被缩短了。我现在都感觉时间是以周为单位消失的，一周一周的消逝，感觉有点吓人。</p>
<p>曾经几个人都问我一个人出去逛有什么意思，一般遇到这样的问题，我都会笑而不答。你说生命又有何意义呢？能够做自己喜欢的事，那就是意义所在吧。</p>
<p>有的人喜欢旅行，有的人不喜欢，就像有的人喜欢游戏，有的人不喜欢一样。每个人的兴趣点不同，喜欢什么，都无可厚非。做自己喜欢的事就是了。</p>
<p>一直工作，如果生活中除了上班、下班，就是加班，那么即使你赚再多的钱又有什么意思呢？生命中需要经历一些多姿多彩的事情，而不是一直枯燥无味地工作。旅行的意义，对我而言，除了可以让自己心情宁静以及产出身心愉悦之感，再有就是，有很多的旅行，多年后回忆往昔的时候，就不会感叹曾经生活得一片空白了。</p>
<p>我喜欢独游，是因为独游有独游的好处。第一就是绝无拘束，一切可以按照自己的兴趣去做，只要忍受一点寂寞，便可换来莫大的自由。旅途中，一切事情都要自己去解决，也可训练独立自主的精神。</p>
<p>再有就是，寻找合适的旅友真是不易。好的旅友，不但要经济能力与你相仿，这样彼此相同的消费标准才不会让彼此在旅程中产生委屈；好的旅友还要臭味相投，这样到了一个地方，才不会出现一人想看这个，一人想看那个，最后无论去哪里，总会出现有人不满意的尴尬局面。</p>
<p>一般去一个城市，我最想去和最先去的，是博物馆。我想很多人应该不会和我一样。</p>
<p>再有，我想走遍祖国的千山万水，我会去很多地方，如果以后条件允许了，我还想环球去很多地方，每去一个地方，都有伴友，几乎不可能啊。</p>
<p>独游 —— 能思想的人应该乐于和自己为伍。一个人，一个背包，一段旅程，其实这样挺好的。</p>
<p>在上海已经四年多了，距离苏州这么近，这次还是我第一次走进苏州城。而旁边的杭州，几年间，我已经去过五六遍了。之所以一直不肯去苏州，是因为从大学开始，我便对苏州有些成见。</p>
<p>时隔多年，对一座城池的成见终于不见了，那么来苏州，也就是顺理成章的事情了。</p>
<p>第一次来苏州，到的时候，已经上午十点了。出了火车站，第一个要去的就是博物馆了。</p>
<p>博物馆距离火车站不算远，本想要步行过去，想着时间可能会比较赶，最后就坐公交去了。</p>
<p>博物馆竟然就在苏州园林附近。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-306434f9714beef7.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="门泊东吴船"></p>
<p>当天是周末，在博物馆排队等候进入的人很多。我排了四五十分钟的队才进入博物馆内。苏州博物馆，一个不小的园区，不像其它城市博物馆建的那样高大，它很有自己的特色，最高的地方也就两三层，大院通体白墙黑瓦，很有古典美。</p>
<p>我在博物馆用了两三个小时，看了各个朝代的历史文物，为它们不同的美深深折服。当时自己很想有些明代那样的家具，希望可以 “家无别况，唐书晋字汉文章”。</p>
<p>博物馆东边出口的地方是太平天国的忠王府。</p>
<blockquote>
<p>在苏州失守后，忠王李秀成回到天京（南京），劝天王洪秀全 “让城别走”，另图发展，遭到天王拒绝，只得留守天京孤城，以孝愚忠。1864 年 7 月19 日湘军用地道炸塌太平门外城墙二十余丈，天京失陷。当晚忠王李秀成拜别母、妻，保护幼天王从太平门破城缺口处突围奔跑广德，因马乏误入天京南郊方山避难。23 日因奸民出卖被俘。在敌人的牢笼里，他写下数万字的自述，8 月 7 日傍晚在南京慷慨就义。</p>
</blockquote>
<p>李秀成出身于一个贫苦农民家庭，幼年和父母一起 “寻食度日”，生活十分艰难。在金田起义参加太平军后，他作战机智勇敢，很快从一名普通的士兵晋升为青年将领。天京变乱后，他与陈玉成、李世贤等力撑危局，取得了二破江北大营、三河大捷、二破江南大营等军事上的胜利，并建立苏福省、天浙省，中兴了太平天国。天王洪秀全封李秀成为忠王，称 “万古忠义”。</p>
<p>太平天国一度有彻底推翻清政府的势头，它作为一个被外国人认可的政权，和清政府共存了十三年，眼见就要成功了，可惜领导者们大多终归是一群草莽。一个偌大的组织，在领导者们的内讧中，顷刻间瓦解土崩。</p>
<p>天京之变以后，北王韦昌辉在天京城中大开杀戒，排除异己，杀死了东王杨秀清。而后天王洪秀全联合翼王石达开内外夹击，又杀死了韦昌辉。韦昌辉死以后，洪秀全又开始怀疑石达开，石达开担心步韦昌辉后尘，于是率部 10 万离开天京，最后在四川省的大渡河被清军围剿兵败。从此以后太平天国元气大伤，再不复以前辉煌。</p>
<p>当年蒋介石围剿红军的时候，也想在大渡河那里让毛泽东步石达开后尘，可惜毛挺过去了，并在胜利后写下了赫赫有名的诗词《七律·长征》，想必我们都熟悉，全文是这样的：</p>
<blockquote>
<p>“红军不怕远征难,万水千山只等闲.<br>五岭逶迤腾细浪,乌蒙磅薄走泥丸.<br>金沙水拍云崖暖,大渡横桥铁索寒.<br>更细岷山千里雪,三军过后尽开颜.”</p>
</blockquote>
<p>忠王府，作为李秀成的府邸，虽经文革的洗礼，但是大体算保存下来了。置身在那个年代的王府中，仿佛让人梦回前朝。</p>
<p>王府门前有李秀成的半身像，据说那是李秀成留下来的唯一画像。画的作者是英国军人呤唎（Augustus Frederick Lindley，1840 年 2 月 3 日－1873 年 3 月 29 日），他曾效力于太平天国军队。呤唎 1857 年加入英国海军，1859 年前往香港服役，次年辞职后前往太平天国控制区经商。1861 年，呤唎正式投效太平天国忠王李秀成，为其训练军队，并多次亲自参战。1863 年，呤唎参加了九洑洲要塞保卫战，身受重伤。伤愈后，呤唎率数人于同年九月潜入上海，夺取了一艘轮船 “飞而复来号”（Firefly），献给太平军。之后，呤唎因为患病不愈，转回英国。1866 年 2 月 3 日，呤唎出版《太平天国革命亲历记》（Ti Ping Tien Kwoh: The History of the Ti-Ping Revolution, Including a Narrative of the Author’s Personal Adventures）一书，记述了他参与太平天国运动的历史，并将其题献给李秀成。</p>
<p>在博物馆，了解一段历史，这也是参观博物馆的好处。在那里，你总可以增长些知识。</p>
<p>由于在博物馆、苏州园林博物馆逗留的时间太长，我本想再去旁边的拙政园、狮子林转转的，时间太赶，就没去。很是遗憾。还有，虎丘、寒山寺也没去成，只能寄希望于下次再去了。</p>
<p>别了博物馆，我朝着金鸡湖方向走去。当然是步行过去的。</p>
<p>在路上有遇见大河，有路过苏州大学，还有见到高大的古城楼，可惜都没能停留太长时间。</p>
<p>不知不觉，我竟然意外地来到了一条苏州历史文化古街–苏州平江历史文化街区。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-df5f78bbd44b0cbf.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="猫的天空之城"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-d9ed5129a51f7b5d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="行走"></p>
<p>开始还以为是条不长的小街，可是走着走着，我发现路好长。那里简直让我喜欢得不得了。小路的一边是古代建筑组成的一个个商铺，那里有昆曲、评弹不时入耳；还有一家家小店，各色小吃；店铺的门面，古色古香，亦今亦古。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-1fe8e29893fd4901.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="转角遇到猫"></p>
<p>小路的另一边是一条小河，河边的风吹动柳树，水波中倒影着婀娜的身姿，时不时一条小船由远驶来，船上三三两两的游客仿若置身画中。我在风景中看画，不想自己也成为画中的一部分了。</p>
<p>那天，我在古街的路边买了块儿山楂糕，吃着酸酸甜甜的，我想起了好多好多年前在老家的大南地摘花生时和奶奶的对话了，“奶奶，这甜甜的叫什么名字？” 奶奶说，“山楂糕，是你爸爸中午回家给我买的。” 从那以后，我记住了有种很好吃的食物叫山楂糕。那还是我很小很小的时候。</p>
<p>如今，好多年过去了，奶奶的样子我都快想不起来了，而父亲，也离我远去了。往事想起来总是悲伤的，而人却要坚强下去。</p>
<p>古街旁边的小店，有可以观看昆曲和评弹的茶馆，在那里，你可以一边喝茶一边欣赏快要失传了的非物质文化遗产，很有民国风的感觉。当时我很想进去体验体验来着，只是因为是一个人，我就没去。如果有她在，我一定会拉她进店听戏的。不久前读过一本书，书中说，张家大小姐张允和就会唱苏州评弹。那个年代，总是让人很向往。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-c41236d05d6d3e89.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="清语堂"></p>
<p>天色侵夕的时候，我只身来到了金鸡湖。我发现，那湖之大，那湖之美，华灯初上时，美好完全不输西湖嘛。初见，就有相见恨晚的感觉。只是当时天在打雷，想要下雨的感觉，加之天黑，没敢在湖边待太久，仓促间去旁边的文化博览中心逛了下。</p>
<p>文化博览中心很壮观，想必应该是苏州的艺术中心了。在那里可以观看歌剧、话剧、电影、演出等，里面还有音乐、美术培训机构，很有艺术气息的地方，很奢华的地方。在那里，我想到了《卡门》，想到了《雪狼湖》，想到了《歌剧魅影》，那些大学必修的音乐课上老师给我们放的歌剧电影。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-cc4d9a3f6aa86238.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="侵夕的雨"></p>
<p>苏州的楼房，咋一看，还没有郑州的楼高、楼新，却是特别有灵性的地方，特别适合养生的地方，和杭州有一比。上有天堂，下有苏杭，果然名不虚传啊。如果和爱人在那样的地方生活，在湖里游船，在湖边垂钓，在一安静处，辟一书房，琴棋书画诗酒花，笔精墨良话平生，也是人生一乐了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-2aa9d643293aa08d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="华灯上"></p>
<p>临别回上海的时候，苏州火车站南广场的夜景又颠覆我的想象了。那里竟然有水，竟然有城楼。晚上，吹着凉风，坐在水边，隔河远远看着对面城楼下几队人在载歌载舞，感觉棒极了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-a42926e6d3b010a3.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="火车站南广场"></p>
<p>那天我坐在河边，我旁边有个戴着白色帽子听着音乐的小哥正在为河对面的城楼写生。这时，我收到一条前辈发来的信息，“上士闻道，勤而行之”，当时心情挺愉悦的，特此记忆一下。</p>
<pre><code>2017.09.22 22:39 
     上海 新泾北苑
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/09/2017/读《将才》/" itemprop="url">
                  读《将才》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-09T11:17:00+08:00" content="2017-09-09">
              2017-09-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书心得/" itemprop="url" rel="index">
                    <span itemprop="name">读书心得</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/09/09/2017/读《将才》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/09/2017/读《将才》/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>能读这本书，完全是因为一位前辈的推荐。</p>
<p>在简书上坚持写博客已经快三年了，这三年里，就个人写作能力，感觉还是有所提高与进步的。前段时间看了一本书《刻意练习》，书中的观点，加上我个人经验，让我觉得如果想要在某个领域做出出色的成绩，刻意的练习是必不可少的。某个训练，如果能够一直坚持下去，刻意练习，日积月累，潜移默化下，结果肯定是喜人的。我想，如果我就这样坚持下去，再过十年，那时再回头看之前写的东西，肯定会感到不成熟和幼稚，但那又怎样，到那时，自己的写作能力会提高一大台阶，而进步的原因正是因为以前对不成熟和幼稚的坚持。</p>
<p>因为写博原因，在简书上结识了一些简友。其中有位前辈，说读了我的文章，感觉和多年之前的他很相似，然后向我提建议，说我的知识结构太单一了，建议我读一些其它方面的知识，比如职场相关的、人际交往相关的、心理学相关的。他说只读文史等经典书籍肯定是不行的。我觉得有道理，然后就请他为我推荐一些书籍。他认真地列了一些他读过的感觉不错的书，其中有一本就是这个《将才》。前两天我读完了它，今天写点感受和总结。这里特别感谢下那位前辈。</p>
<p>读了本书，让我觉得自己以前在职场上犯了好多忌讳。工作五年来，在为人处世方面，我有很多不足。</p>
<p>书中书说，“知识本身是没有价值的，而被运用后的结果，才是知识的价值”，这个也适用于读书。如果你认真读完一本书，你花费了时间，可是到最后却没有任何收获，隔了段时间，甚至刚读完那本书，你就忘了书中说了什么，书的主题是什么，作者想要通过那本书向你传达的信息是什么。这样可不好。</p>
<p>现在我认为思维导图很不错。它可以用来记笔记。思维导图，可以电脑绘制也可以自己手绘，最好能够好看、清晰，以后复习的时候，看着导图，根据关键词，就可以对书有个清晰的回顾。接下来，我要多尝试使用思维导图做笔记和头脑风暴了。</p>
<p>书中有很多教人处事的小细节，很实用，比如：</p>
<blockquote>
<p>主管意识<br>不再一人饱全家饱，行事与决策要习惯由组织的角度思考。将帅无能累死三军。</p>
<p>能力强只是正面的加分，但性格上的缺点带给别人的负面印象，却会产生很大的减分效应。</p>
<p>领导就像船长，要能阻止一群人，朝向共同目标奋力迈进。</p>
<p>身为主管，要管大事还是小事？</p>
<p>如果认为把分内事情顾好就是负责任，那么多部门或者多人交叉的灰色地带怎么办？</p>
<p>主管每天忙得不亦乐乎，显得自己很忙，很有贡献，很重要，部门一日没有主管便无法操作。这种管理模式，可说时一种严重的错误，不仅部门成员的专业性不能提升，且部门运作容易陷入混乱。</p>
<p>管理的要诀就是要善用制度化管理。</p>
<p>一个人的穿着会影响这个人的心情，以及整个群体的气氛</p>
</blockquote>
<p>就我而言，我曾经在工作中遇到的最大问题，不是技术问题，而是怎么适应环境怎么与直接领导或者上层领导相处的问题。</p>
<p>这里问个问题，如果工作中你遇到一个脾气暴躁的直接主管怎么办？如果他经常当众吆喝你怎么办？如果他在背后议论你说你坏话怎么办？</p>
<p>或者你会说，“要么忍，要么滚！”</p>
<p>可是如果你换了家工作单位，然后又遇到同样的问题怎么办？要知道，很多时候，很多工作，无论在那里，很多事情差不多都一样的。</p>
<p>或许只有自己创业，然后做成功了，自己成了一家公司里职位最高的人，那样才能从根本上解决在工作中遭受憋屈的待遇。但是，做企业，又多少人能成功呢？</p>
<p>这是一个问题。这个问题不但工作中有，生活中也处处可见，如果你的亲戚、朋友、发小儿、同学、同事背地里说你坏话，然后恰巧让你知道了，在面对他们的时候，你会怎么办呢？</p>
<p>装做不知？除非你演技很好，不然，我想你做不到。</p>
<p>与人打交道，是门巨大的学问，比和机器交流难多了。</p>
<p>我们总是在意别人的言论，不敢做自己喜欢的事情，追求自己想爱的人，害怕淹没在飞短流长之中。其实没有人真的在乎你在想什么，不要过高估量自己在他人心目中的地位。被别人议论甚至误解都没什么，谁人不被别人说，谁人背后不说人，你生活在别人的眼神里， 就迷失在自己的心路上。 ​​​​</p>
<blockquote>
<p>注:本来要放弃写这篇读后感了，因为今天事情有点多，可是最后还是写了。一是因为外面下雨了，喜欢下雨时候写字的感觉，二是因为，觉得每读一本非专业的书，都要认真对待，认真对待的方法就是写读书笔记，就像每去一个城市，就要写篇游记一样，这是态度问题。</p>
</blockquote>
<pre><code>2017.09.09 11:17
     上海 新泾北苑
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/07/2017/再见洛阳/" itemprop="url">
                  再见洛阳
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-07T23:24:00+08:00" content="2017-09-07">
              2017-09-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/周游天下/" itemprop="url" rel="index">
                    <span itemprop="name">周游天下</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/09/07/2017/再见洛阳/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/07/2017/再见洛阳/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周末去了趟洛阳。</p>
<p>时隔七年半，我再次来到了神都。</p>
<p>记得上次来洛阳，还是我大二时候，那年和舍友马雷、文君、刘岩一起去了文君家。文君家在洛阳偃师，距离白马寺很近，开车大概有十几分钟的车程。大学时候，时间总是那么充裕，周末或者假期时候，是最好的旅游季。可惜那年头，我总是囊中羞涩，不然以我的性格，四年里，我肯定会去很多地方。因为那时没钱，自己少了很多出去浪的机会。</p>
<p>不过洛阳距离郑州实在够近，如果大学期间不去转转的话，以后想起来肯定会追悔莫及的。记不清当时是谁先提的了，可能是马雷，也可能是我，当时一问有没有要去洛阳的，然后宿舍里四个人就达成了一致意见，文君是洛阳的，他说，“我们去我家吧？”  我们几个说，“好”。</p>
<p>可惜的是，当年周洋和亚桥没有去。记得当时周洋在犹豫要不要去，他就问亚桥去不，亚桥一直着迷于他的游戏，加上他本身不爱旅游，然后他们两个就不去了。至今回想，很是遗憾。</p>
<p>这次去洛阳，主要是参加文君的婚礼。这次周洋、亚桥都去了，倒是马雷和刘岩远在深圳，回去一次不容易，他们没有去。虽然我在上海距离也不近，有一千多公里了，但一是因为想见见久未谋面的同学，一是想再转转古都洛阳，当然最重要的还是因为想参加文君婚礼，婚礼恰逢在周末，我就当然去了。</p>
<p>时隔近八年，故地重游，不禁让人感慨、唏嘘。时间过得可真快啊！八年，不知不觉都过去了，想想人生一世，有多少个八年呢？</p>
<p>上周六中午时分，我到达了洛阳龙门站，距离下午和文君他们约好的时间尚早，想着好久没见利帅了，去年过年时候，本来和他约好要去他家聚会，因为几个人时间赶不到一块儿去，最后竟然没有见成。这次来了洛阳，我想，即使挤时间也要见见利帅的。</p>
<p>利帅，我的高中同学，我的老乡，家是桃花洞的，他家距离我家大概有七八里地那么远，据说他们村曾经出了个名人 – 蔡邕, 对，就是蔡文姬他老爸，不知道真假，不过据说曾在他们村附近发现有蔡邕的墓碑。因为这样原因，我们乡，又有书法之乡的称呼。</p>
<p>那天见了利帅，在一家老店里，他请我吃了洛阳的特色水席，饭店的位置有点不太好找，不过里面给人的感觉很不错。饭店有点像一户人家，又有点像北京胡同，大门是一个很窄的过道，进到里面，可以上楼，也可以在楼下。当时时间都快下午一点了，还有不少的人在排队。我们在那里等了有二十分钟左右，中午轮到我们了，我俩进了一间屋，只见那里摆了三个方桌长凳，墙上有不太清晰看着像印象派的画，给人感觉，像是进了武侠小说里的客栈。虽然那次吃的水席不太和我的胃，但是那种感觉和体验却是不错的。</p>
<p>吃过午饭，我和利帅一起逛了那附近的民俗博物馆和洛河。在洛河旁边，我想到了洛神赋，想到了伊水，想到了 “河出书，洛出图”……</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-f699e93c498e8d95.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天后宫"><br><img src="http://upload-images.jianshu.io/upload_images/130752-3f783c07212043e9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="十字街"><br><img src="http://upload-images.jianshu.io/upload_images/130752-de1860119157c328.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="风俗博物馆"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-2a94dbea88e13dde.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="茶楼"><br>山之南，水之北，即为阳。因为洛阳城在洛水的北边，所以叫洛阳。洛神为中国神话里伏羲氏（宓羲）之女，因于洛水溺死 ，而成为洛水之神，即洛神。洛神赋因为曹植而著名。<br><img src="http://upload-images.jianshu.io/upload_images/130752-fd288b86a3af5067.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="洛水"></p>
<p>利帅是 985 院校毕业的高才生，毕业后却选择了在洛阳工作，在一个小城市里，享受着慢节奏的生活，不像在大都市里那样每天焦虑着忙忙碌碌，虽然没有大都市里那样多的机会和相对较好的待遇，然而每个人的追求不一样，或许小城中的那种缓慢，那种平和才是真的生活，而在大城市中打拼的我们，活得却是像在生存。洛阳的街，没有大都市的喧嚣，没有拥堵，没有快节奏。那天天空飘着小雨，我漫步在古都的街头，内心多的是一种安静和祥和。</p>
<p>大上海，理性的物质世界，每天工作超过 10 个小时，内心焦躁不安，生活围绕着上班，下班，加班而展开，时间过得飞快，大多数人甚至没有时间去欣赏日落之美。这样的日子，和每天轻松自在，平均每周有一天钓鱼时间相比，如果不为生计烦恼，你选择哪种生活呢？</p>
<p>我在想，如果有天我财富自由了，我是一定要换种生活方式的。因为当你感到每天过得飞快的时候，相对来说，就等于拉短了你的寿命。同样是一天，在老家那样过活，和在上班时候对比，那种时间快慢感觉完全不一样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-19903fe56e6a2f7f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垂钓"></p>
<p>别过利帅，下午五点半我到了白马寺，和文君约好了在白马寺门口集合。</p>
<p>因为还要等其他几个人，我去早了一会，大概有一个小时的空档期，我没有忍住，在那个时间，我花钱买票进了白马寺。当时寺庙都快关门了。</p>
<p>在白马寺门口，看着寺庙大门上那几个大字，看着那两匹石马，不禁让我想起了多年前的种种事情。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-149cb852ab53a931.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="白马寺"></p>
<p>记得那一年，我曾在寺院的石龟前和他们一起拍照哈哈大笑;<br>记得那一年，我们几个在寺庙前的水塘边听一位大妈讲她信佛后发生的种种奇特故事，当时我问她知道不知道弘一法师;<br>记得那一年，我们惊奇的发现狄仁杰的墓竟然在寺东南角的树林里，刘岩指着墓碑问我，“有唐功臣的有唐是什么意思？” 当时的我竟然回答不出来;<br>记得那一年，我还调皮地骑上了路边的一个白色石马。<br><img src="http://upload-images.jianshu.io/upload_images/130752-24f5878858302f35.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="乌龟"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-980fd463bf985519.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="鸽子"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-31241d4936dfdb71.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="古树"></p>
<p>当时我不知道，一直我都不知道，直到这次，我才意识到那两匹白马是狄大人的守护神，因为它们距离狄公的墓很近，又是在第一个路口边。我发现当年我有所冒犯了。那天走在那里，我一直在想，希望狄公能够恕我不知者不罪了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-51085b747e59dc5e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="狄公"></p>
<p>当年刘岩问我是什么意思的那几个字，依稀记得，那年它们表面的白色粉末很清晰，虽然石碑在小亭子下面，又有玻璃罩体，但是现在那些白色粉末几乎没有了，只剩下头一两个字的白色还比较清晰。站在那里，我不禁感慨，时间真快呀！后来在送我和 “团长” 回火车站的路上，一边开着车的文君说，“前不久我和同学又去龙门石窟了，这次我发现，好多石窟比上次我们看的时候破坏的更严重了…” </p>
<p>八年，确实是不短的时间。时间潜移默化，可以改变很多人，也可以改变很多东西。</p>
<p>这次在白马寺，我又长了一点知识。算是两次门票没有白买。</p>
<blockquote>
<p>白马寺的营建与中国历史上的 “永平求法” 紧密相连。东汉明帝曾夜梦金人，身高六丈，顶佩白光，自西方飞来。大臣傅毅认为这是西方的佛，汉明帝遂 “感梦求法”，令蔡愔、秦景、王遵等十余人于永平七年（64年）赴天竺（古代印度）求佛法。他们在西域的大月氏（古代阿富汗）遇到了来自天竺的僧人摄摩腾和竺法兰，得佛经佛像，于是相偕同行，以白马驮经，并于永平十年（67年）来到当时的京城洛阳。为了给两位高僧一个居住和译《四十二章经》的地方，汉明帝敕命在城西的雍门外按天竺式样建造了一组建筑，以僧人们暂住的 “鸿胪寺” 的 “寺” 字称之，为了纪念白马驮经之功，便将这组建筑命名为 “白马寺”。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/130752-9118ab4f41578795.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一古刹"></p>
<p>这次在洛阳，连着两天，我进了两次白马寺。头天晚上，正赶上僧人们在大佛殿唱歌做法事。当时我看到一个年轻的领班，想着他应该是方丈，只见他戴着眼镜，给人感觉很儒雅很有气质，关键还很年轻，他身后跟着好几个老和尚。</p>
<p>第二天再去白马寺，看里面展览图画，我才知道，其实白马寺现任方丈并不年轻，他年龄已经有五十出头了，可是看起来却只有三十岁上下，不知道是不是修行修来的。</p>
<p>回到公司，我给同事讲，同事说，估计他能活到一百岁。</p>
<p>在白马寺里面，有一间展览馆，上面列着自东汉以来各朝白马寺大德高僧，现任方丈印乐大和尚排在最后一位，我是在那里看到他的年龄的。</p>
<p>中国文化一直被儒道释深深影响着，其中佛教（始于东汉汉明帝时期）相对于儒家（始于东周战国时期）和道家（始于东周战国时期），进入中国最晚，但是他的影响，较之前两家，有过之而无不及。佛教自印度传入东土以来，在中原得以发展壮大，继而传入西藏、日本、东南亚等诸国，其影响之大，甚至超出了印度。</p>
<p>东汉汉明帝，估计很少人知道他，他名气不算大，但也算是一个有作为的好皇帝了。班超班固，就是他那个时代的人。班超投笔从戎的故事，想必很多人都听说过。他随大将军窦固出击北匈奴，为大汉朝立下赫赫战功。官西域都护，封定远侯，世称“班定远”。</p>
<p>但是如果提起汉明帝的父母，就无人不知无人不晓了。他父亲是汉光武帝刘秀，他妈妈是汉光烈皇后阴丽华。</p>
<p>想起光武帝，就想起了他那句名言，“仕宦当作执金吾,娶妻当得阴丽华”。感觉和项羽说的那句 “彼可取而代也”（秦始皇帝游会稽,渡浙江,梁与籍俱观.籍曰：’彼可取而代也.’），以及刘邦见到始皇帝的仪仗后说的“大丈夫当如此也！” 有异曲同功之妙。大凡伟人，从一开始就立下了不俗的志向啊！</p>
<p>洛阳城边，有刘秀墓，这位雄才大略的皇帝，可以和秦皇汉武唐宗宋祖相并列，每次读到他，敬仰之情不免油然而生，而他与阴丽华的爱情故事更是感人至深。来到洛阳，实在想去拜访一下，这次时间太赶，没能成行，实在可惜。</p>
<p>洛阳有着 5000 多年的文明史、4000 多年的建城史和 1500 多年的建都史，夏朝、商朝、西周、东周、东汉、曹魏、西晋、北魏、隋朝、唐朝、武周、后梁、后唐、后晋等十三个王朝在洛阳建都，有十三朝古都之称，有全国重点文物保护单位43处，馆藏文物40余万件。</p>
<p>那里有白居易，狄仁杰，武媚娘 ……</p>
<p>对历史着迷，对古代文化钟情，如果还没有去过洛阳的，那你一定要去看看了。</p>
<pre><code>     上海 新泾北苑 
2017.09.07 23:24
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/06/2017/Firebase-Tutorial--Getting-Started-中文版/" itemprop="url">
                  Firebase-Tutorial--Getting-Started-中文版
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-06T17:02:00+08:00" content="2017-09-06">
              2017-09-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术博客翻译/" itemprop="url" rel="index">
                    <span itemprop="name">技术博客翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/09/06/2017/Firebase-Tutorial--Getting-Started-中文版/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/06/2017/Firebase-Tutorial--Getting-Started-中文版/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          


          
           

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>备注:</em>  本教程已由 Attila Hegedüs 更新适配 iOS 10 和 Swift 3，原教程由David East 创作。<br>原文：<a href="https://www.raywenderlich.com/139322/firebase-tutorial-getting-started-2" target="_blank" rel="external">https://www.raywenderlich.com/139322/firebase-tutorial-getting-started-2</a><br>翻译：JoeyChang     转载请标明出处</p>
</blockquote>
<p>Firebase 是一个移动后台服务，它可以帮助我们创建具有优秀特性的移动 apps。Firebase 提供以下三个主要服务:  a realtime database, user authentication and hosting。通过集成 <a href="https://firebase.google.com/docs/ios/setup" target="_blank" rel="external">Firebase iOS SDK</a>, 你几乎不用写一行代码就能创建出非常棒的应用。</p>
<p> <a href="https://firebase.google.com/" target="_blank" rel="external">Firebase</a> 具有数据库实时性这样的独特性能。</p>
<p>你曾经使用过 pull-to-refresh 去拉新数据么？有了 Firebase，现在你可以忽略那种刷新数据方法了。</p>
<p>当 Firebase 数据库更新时，所有的连接者可以实时获取更新，这就意味着你的 app 可以不用用户交互就能获取数据库当前最新值。</p>
<p>本篇 Firebase 教程中，我们将通过创建一个名叫 <em>Grocr</em> 的具有协作性的grocery list app , 来学习Firebase 的一些基本原理。当我们添加一个项目到列表时，它将实时出现在用户的其它设备中，但是我们并不满足于此，我们还将调整 Grocr 让它可以离线工作，以致即使仅有一个 grocery 数据连接，列表也能保持同步。</p>
<p>通过本文，你将学习到以下技能：</p>
<ul>
<li>保存数据到Firebase数据库</li>
<li>从 Firebase 实时同步数据</li>
<li>验证 users</li>
<li>在线监控 users</li>
<li>实现离线支持</li>
</ul>
<p>开始，下载初始项目 <a href="https://koenig-media.raywenderlich.com/uploads/2016/09/Grocr-starter.zip" target="_blank" rel="external">Grocr-starter</a>. 它使用 CocoaPods 管理 Firebase 。</p>
<p>在 Xcode 中打开  <em>Grocr.xcworkspace</em>，该项目包含三个view controllers：</p>
<ol>
<li><p><em>LoginViewController.swift</em>.<br>现在登录功能还是使用的硬编码 user credentials，稍后我们将优化它。</p>
</li>
<li><p><em>GroceryListTableViewController.swift</em>.<br>这个 controller 是 UITableViewController 子类，它通过 UIAlertController 添加 items 到本地数据库的 list 表格。</p>
</li>
<li><p><em>OnlineUsersTableViewController.swift</em>.<br>该 controller 使用 Firebase’s <em>presence</em> feature  展示所有当前在线 users。</p>
</li>
</ol>
<p>此外，还有两个模型类 <em>GroceryItem.swift</em> 和 <em>User.swift</em> 。它们做为 app 的数据模型。</p>
<p>Build and run, 你将看到如下这样效果:</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/Grocr-Starter.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-a022ff458ff53d8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Grocr-Starter"></a></p>
<p><em>注:</em> 当 build 工程时，我们将看到一些  ‘nullability’  编译警告。它们来自Firebase，暂时我们先忽略它们，稍后解决。</p>
<p>我们可以点击 <em>Login</em> 进行登录，这将使用一个写死的 user 数据，现在该 app 还只能使用本地数据。接下来我们将调用 Firebase 数据使 app 生动起来。</p>
<h5 id="创建-Firebase-账号"><a href="#创建-Firebase-账号" class="headerlink" title="创建 Firebase 账号"></a>创建 Firebase 账号</h5><p>有两个重要步骤：</p>
<ol>
<li>创建免费 Firebase 账号</li>
<li>获取你第一个 app 的 URL</li>
</ol>
<p>我们可以访问 <a href="https://console.firebase.google.com/" target="_blank" rel="external">Getting Started page</a> 进行注册。当我们使用我们谷歌账号共享登录进入 firebase, 我们将看到一个干净的 Firebase 控制台。不要担心费用问题，现在 Firebase 免费版本已经足够强大，够用了。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/01-firebase-welcome.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-b93dd5e3699cf7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01-firebase-welcome"></a><br>创建我们的第一个工程，点击  <em>CREATE NEW PROJECT</em> 。在弹出的对话框中输入项目名称以及你的首选 国家/地区：</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/02-firebase-create-project.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-157b9bcc3dbd7fa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-firebase-create-project"></a></p>
<p>点击  <em>CREATE PROJECT</em>, 我们就可以通过控制面板来管理我们的项目了。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/03-firebase-dashboard.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-f6337012f497ddf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-firebase-dashboard"></a></p>
<p>这将作为所有 Firebase 服务的容器，我们用它存储数据和授权用户。<br>选择 <em>Add Firebase to your iOS app</em> 开始我们的项目。本项目的 bundle ID 是 rw.firebase.gettingstarted，所以添加此 id 到  <em>iOS bundle ID</em> 文本框。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/04-firebase-add-ios-app-1.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-1d990d350dc4f89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04-firebase-add-ios-app-1"></a></p>
<p>点击 <em>ADD APP</em> ，将下载一个 <em>GoogleService-Info.plist</em> 文件。将该文件拖拽到 Xcode 中的 Grocr 项目。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/04-firebase-add-ios-app-2.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-b76a1b43f6ab6c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04-firebase-add-ios-app-2"></a></p>
<p>点击 <em>CONTINUE</em>. 接下来一页描述怎样安装 Firebase SDK。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/04-firebase-add-ios-app-3.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-20b35cd28617e4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04-firebase-add-ios-app-3"></a></p>
<p>本项目已经替我们集成好了，所以点击 <em>CONTINUE</em> 继续。最后一页说明当 app 启动时怎样连接到 Firebase。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/04-firebase-add-ios-app-4.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-74f46d040e7bc402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04-firebase-add-ios-app-4"></a></p>
<p>点击  <em>FINISH</em> ，查看新项目细节。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/04-firebase-add-ios-app-5.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-ba5b641678eaa3c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04-firebase-add-ios-app-5"></a></p>
<p>在 <em>Xcode</em> 打开 <em>GroceryListTableViewController.swift</em> ，添加如下代码，创建 Firebase 连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let ref = FIRDatabase.database().reference(withPath: &quot;grocery-items&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这个 Firebase 连接使用已提供的 path。在 <a href="https://firebase.google.com/docs/reference/ios/firebasedatabase/interface_f_i_r_database" target="_blank" rel="external">documentation</a> 中，这些 Firebase 属性被称为 <em>references</em> ，它们指定 Firebase 的位置。</p>
<p>简言之，这些属性可以实现保存和同步数据到给定的位置。</p>
<p>我们发现，base URL 不是必须的，相反，它使用 grocery-items 的 child path。Firebase 数据库是 JSON <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a> 数据库，所以数据都是保存为 JSON 格式。</p>
<p>JSON 是分等级的 key-value 数据结构 – keys 指的是可以根据它获取其它对象格式的 values 值。JSON data 是一个简单的 key value 对儿树形结构。</p>
<p>在 Firebase 中，<em>key</em> 是一个 URL，<em>value</em>是形如 number, string, boolean , object 的随意的数据。</p>
<h5 id="Structuring-Data"><a href="#Structuring-Data" class="headerlink" title="Structuring Data"></a>Structuring Data</h5><p>无论客户端是什么数据格式，保存到 Firebase 的是 JSON 格式。下面是一个 JSON 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// The root of the tree</span><br><span class="line">&#123; // grocery-items </span><br><span class="line">    &quot;grocery-items&quot;: &#123; </span><br><span class="line">         // grocery-items/milk </span><br><span class="line">          &quot;milk&quot;: &#123;</span><br><span class="line">                // grocery-items/milk/name </span><br><span class="line">               &quot;name&quot;: &quot;Milk&quot;, </span><br><span class="line">                </span><br><span class="line">               // grocery-items/milk/addedByUser </span><br><span class="line">              &quot;addedByUser&quot;: &quot;David&quot; </span><br><span class="line">          &#125;,</span><br><span class="line">         &quot;pizza&quot;: &#123; </span><br><span class="line">               &quot;name&quot;: &quot;Pizza&quot;,</span><br><span class="line">                &quot;addedByUser&quot;: &quot;Alice&quot;</span><br><span class="line">          &#125;, </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的 JSON 中，你可以看到每对儿数据都是以键值对儿形式出现的。我们可以继续遍历树并在更深的位置检索数据。</p>
<p>在上面的例子中，我们可以通过路径检索所有的 grocery item。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grocery-items</span><br></pre></td></tr></table></figure></p>
<p>如果你想获取第一个 grocery item ，你可以通过以下路径获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grocery-items/milk</span><br></pre></td></tr></table></figure></p>
<p>因为所有的 Firebase keys 对应paths，所以 key 的名字选择很重要。</p>
<h4 id="Understanding-Firebase-References"><a href="#Understanding-Firebase-References" class="headerlink" title="Understanding Firebase References"></a>Understanding Firebase References</h4><p>一个基本的原则是，Firebase 引用指向 Firebase 中数据存储的位置。如果我们创建多引用，那么这些引用共享同一个连接。<br>看如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let rootRef = FIRDatabase.database().reference()</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">let childRef = FIRDatabase.database().reference(withPath: &quot;grocery-items&quot;)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">let itemsRef = rootRef.child(&quot;grocery-items&quot;)</span><br><span class="line"></span><br><span class="line">// 4</span><br><span class="line">let milkRef = itemsRef.child(&quot;milk&quot;)</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">print(rootRef.key)   // prints: &quot;&quot;</span><br><span class="line">print(childRef.key)  // prints: &quot;grocery-items&quot;</span><br><span class="line">print(itemsRef.key)  // prints: &quot;grocery-items&quot;</span><br><span class="line">print(milkRef.key)   // prints: &quot;milk&quot;</span><br></pre></td></tr></table></figure>
<p>下面我们解释下:</p>
<ol>
<li>我们创建一个到 Firebase 数据库 root 引用。</li>
<li>使用一个 URL ，我们可以创建一个引用到 Firebase 数据库的子路径。</li>
<li>通过给 rootRef 传递子路径，我们可以使用 child(_:) 创建子引用，这个引用和上面的引用是一样意思。</li>
<li>使用 itemsRef ，我们可以创建到 milk 的子引用。</li>
<li>每个引用都有 key 属性。这个属性和 Firebase 数据库关键字的名字一样。</li>
</ol>
<p>我们不需要在同一个项目中都添加这样的代码，这里只是出于展示目的进行列举。</p>
<h3 id="Adding-New-Items-to-the-List"><a href="#Adding-New-Items-to-the-List" class="headerlink" title="Adding New Items to the List"></a>Adding New Items to the List</h3><p>在 <em>GroceryListTableViewController.swift</em> 的底部，找到 addButtonDidTouch(_:) 方法。</p>
<p>在这里我们要实现通过  <em>UIAlertController</em> 的方式添加一个新的  item 。</p>
<p>在 saveAction 方法内，现在仅仅保存数据到一个本地 array，因此 saveAction 不能同步不同客户端的数据，而且在下次启动 app 时，保存的数据将丢失。</p>
<p>没有人会使用不能记录或者同步他们 grocery 清单数据的 app ! 让我们完善 saveAction 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let saveAction = UIAlertAction(title: &quot;Save&quot;,</span><br><span class="line">                               style: .default) &#123; _ in</span><br><span class="line">    // 1</span><br><span class="line">    guard let textField = alert.textFields?.first,</span><br><span class="line">      let text = textField.text else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    // 2</span><br><span class="line">    let groceryItem = GroceryItem(name: text,</span><br><span class="line">                           addedByUser: self.user.email,</span><br><span class="line">                             completed: false)</span><br><span class="line">    // 3</span><br><span class="line">    let groceryItemRef = self.ref.child(text.lowercased())</span><br><span class="line"></span><br><span class="line">    // 4</span><br><span class="line">    groceryItemRef.setValue(groceryItem.toAnyObject())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释如下：</p>
<ol>
<li><p>从 alert controller 获取 text field 和它的内容。</p>
</li>
<li><p>使用当前用户数据创建一个新的 GroceryItem 。</p>
</li>
<li><p>使用 child(_:) 创建一个子引用，这个引用的 key 是 item 的小写名称，因此如果我们添加一个复制的 item （即使使用大写字母，或者使用混合字母），数据库只保存最后一个。</p>
</li>
<li><p>使用 setValue(_:) 保存数据到数据库。这个方法期望一个字典格式。GroceryItem 有个 toAnyObject() 方法，可以转换对象为字典格式。 </p>
</li>
</ol>
<p>在你可以连接数据库之前，我们还需要配置它。找到 <em>AppDelegate.swift</em> ，并在 application(_:didFinishLaunchingWithOptions:) 返回 true 之前添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FIRApp.configure()</span><br></pre></td></tr></table></figure>
<p>默认情况，Firebase 数据库需要用户授权读写权限。在浏览器进入 Firebase 控制面板，选中左边的  <em>Database</em> 选项，设置 <em>RULES</em> 如下：</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/rules_tab.png" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-6c698832572026bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="firebase-db-rules"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;.read&quot;: true,</span><br><span class="line">    &quot;.write&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后，选择 <em>PUBLISH</em>  按钮进行保存设置。<br>Build and run. 在 Firebase 控制面板，选择 <em>DATA</em> 标签，并将浏览器窗口紧挨模拟器。当我们在模拟器中添加 item ，我们将看到它会出现在控制面板。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/07/fb-save.gif" target="_blank" rel="external"><img src="http://upload-images.jianshu.io/upload_images/130752-b4be74d5dcb756c8.gif?imageMogr2/auto-orient/strip" alt="fb-save"></a></p>
<p>现在，我们就有了一个可以实时添加数据到 Firebase 的活生生的 grocery list app！但是虽然 key 特性已经可以运行完好了，但是没有数据添加到table view。</p>
<p>那么我们怎样才能将数据从数据库同步到  table view 呢？</p>
<h3 id="Retrieving-Data"><a href="#Retrieving-Data" class="headerlink" title="Retrieving Data"></a>Retrieving Data</h3><p>我们可以通过 observeEventType(_:withBlock:) 方法异步检索 Firebase 中的数据。</p>
<p>在  <em>GroceryListTableViewController.swift</em> 的 viewDidLoad() 下添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ref.observe(.value, with: &#123; snapshot in</span><br><span class="line">  print(snapshot.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>该方法有两个参数：FIRDataEventType 的一个实例以及一个闭包。</p>
<p>event type 确定我们要监听的事件，.value 监听诸如 add, removed, changed 这样的 Firebase 数据库重点数据改变。</p>
<p>当改变发生，数据库使用最新数据更新 app 显示。</p>
<p>app 在闭包方法中通过接受到的 FIRDataSnapshot 一个实例获知数据改变。snapshot，代表某个特定时间点的数据快照。我们可以通过 value 那个属性获取到 snapshot 的数据。</p>
<p>Build and run，我们将看到，在控制台会有 items 列表数据被打印出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional(&#123;</span><br><span class="line">    pizza =     &#123;</span><br><span class="line">        addedByUser = &quot;hungry@person.food&quot;;</span><br><span class="line">        completed = 0;</span><br><span class="line">        name = Pizza;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="Synchronizing-Data-to-the-Table-View"><a href="#Synchronizing-Data-to-the-Table-View" class="headerlink" title="Synchronizing Data to the Table View"></a>Synchronizing Data to the Table View</h4><p>注意打印日志–现在在 table view 中可以看到 grocery 列表了。</p>
<p>在 <em>GroceryListTableViewController.swift</em>, 替换之前的代码片段为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">ref.observe(.value, with: &#123; snapshot in</span><br><span class="line">  // 2</span><br><span class="line">  var newItems: [GroceryItem] = []</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  for item in snapshot.children &#123;</span><br><span class="line">    // 4</span><br><span class="line">    let groceryItem = GroceryItem(snapshot: item as! FIRDataSnapshot)</span><br><span class="line">    newItems.append(groceryItem)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 5</span><br><span class="line">  self.items = newItems</span><br><span class="line">  self.tableView.reloadData()</span><br><span class="line">&#125;)</span><br><span class="line">``` </span><br><span class="line">以上代码的诸行解释：</span><br><span class="line"></span><br><span class="line">1.  添加一个监听器监听 grocery-items 改变了什么。</span><br><span class="line"></span><br><span class="line">2. 存储最近一次版本数据到闭包中本地的一个变量中。</span><br><span class="line"></span><br><span class="line">3. 监听者闭包返回最近数据的一个 snapshot，这个 snapshot 包含所有的 grocery items，而不是仅仅包含改变的 items。使 snapshot.children ，我们可以循环获取 grocery items 。</span><br><span class="line"></span><br><span class="line">4. GroceryItem 结构有一个常用的实例化器，它使用 FIRDataSnapshot</span><br><span class="line">来填充它的属性。snapshot 的值可以为任意类型，可以是  dictionary, array, number, or string。当创建好一个 GroceryItem 实例，它被添加到一个包含最近一次版本数据的数组中。</span><br><span class="line"></span><br><span class="line">5.  将最新版本的数据赋值给 items，然后更新 table view，使它展示最新数据。</span><br><span class="line">Build and run. 添加一个 pizza item 怎么样？ 它将显示到 table view。</span><br><span class="line"></span><br><span class="line">[![fb-sync](http://upload-images.jianshu.io/upload_images/130752-7d4bbd79c43a073c.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-sync.gif)</span><br><span class="line">不用刷新，就可以及时获取到更新后的数据。</span><br><span class="line"></span><br><span class="line">[![realtime-updates](http://upload-images.jianshu.io/upload_images/130752-982812f3fdca27e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://koenig-media.raywenderlich.com/uploads/2015/07/realtime-updates.png)</span><br><span class="line"></span><br><span class="line">#### Removing Items From the Table View</span><br><span class="line"></span><br><span class="line">table view 将同步我们所有的改变数据， 但是当我们想删除 pizza 时，现在还不能更新。</span><br><span class="line"></span><br><span class="line">为了通知数据库删除数据，我们需要设置一个 Firebase reference，当用户轻扫时候删除 item。</span><br><span class="line"></span><br><span class="line">定位到 tableView(_:commit:forRowAt:)。现在，该方法使用 index 移除 array 中的 grocery item。这可以实现功能，但我们还有更好的解决方法。替换为如下实现方式：</span><br></pre></td></tr></table></figure>
<p>override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {<br>  if editingStyle == .delete {<br>    let groceryItem = items[indexPath.row]<br>    groceryItem.ref?.removeValue()<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Firebase 遵从单向数据流模型，因此 viewDidLoad() 的 listener 监听 grocery list 的最新数据。清除 item 触发数据改变。</span><br><span class="line"></span><br><span class="line">index path 的 row 被用来获取相关的 grocery item。每个  GroceryItem 拥有一个名为 ref 的 Firebase reference property，调用 它的 removeValue() 将移除我们在 viewDidLoad() 定义的 listener。该listener有一个闭包，它使用最新的数据重新加载表视图。</span><br><span class="line"></span><br><span class="line">Build and run. 轻扫 item ，点击删除，我们发现 app 和 Firebase 的数据都消失了。</span><br><span class="line"></span><br><span class="line">[![fb-delete](http://upload-images.jianshu.io/upload_images/130752-010e75171151d250.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-delete.gif)</span><br><span class="line"></span><br><span class="line">Nice work! 我们 items 可以实时删除了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Checking Off Items</span><br><span class="line"></span><br><span class="line">现在我们知道了怎么添加、删除以及同步 items ，这很酷。但是当我们实际购物时候会怎样呢？我们会删除我们刚购买的物品么，或者当我们添加购物车时给物品打个标记是否更好？</span><br><span class="line"></span><br><span class="line">在以前的纸质时代，人们过去常常把东西从购物清单上划掉，因为我们也将在我们的 app 用现代的方式模仿这个行为。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[![grocery-list](http://upload-images.jianshu.io/upload_images/130752-926e622581550b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://koenig-media.raywenderlich.com/uploads/2016/07/grocery-list.png)</span><br><span class="line"></span><br><span class="line">打开 *GroceryListTableViewController.swift* ，找到  toggleCellCheckbox(_:isCompleted:) 方法，该方法可以根据 item 是否完成来切换UITableViewCell 的必要视图属性。</span><br><span class="line"></span><br><span class="line">当  table view 第一次加载后，刚方法在tableView (_:cellForRowAtIndexPath:) 中会被调用，以及当用户点击 cell 时也会被调用。</span><br><span class="line"></span><br><span class="line">替换  tableView(_:didSelectRowAt:) 方法为如下：</span><br></pre></td></tr></table></figure></p>
<p>override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {<br>  // 1<br>  guard let cell = tableView.cellForRow(at: indexPath) else { return }<br>  // 2<br>  let groceryItem = items[indexPath.row]<br>  // 3<br>  let toggledCompletion = !groceryItem.completed<br>  // 4<br>  toggleCellCheckbox(cell, isCompleted: toggledCompletion)<br>  // 5<br>  groceryItem.ref?.updateChildValues([<br>    “completed”: toggledCompletion<br>  ])<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">以下为详细注解：</span><br><span class="line">1. 使用 cellForRow(at:) 确定用户点击的 cell。</span><br><span class="line">2. 根据 index path 的 row 获取对应的 GroceryItem。</span><br><span class="line">3. 改变 grocery item 的 completed 的状态。</span><br><span class="line">4. 调用 toggleCellCheckbox(_:isCompleted:) 更新 cell 的属性。</span><br><span class="line">5. 在 updateChildValues(_:) 方法中，通过传递字典参数，更新Firebase。该方法与 setValue(_:) 不同，因为它只应用更新，而setValue(_:) 具有破坏性，并在该引用中替换整个值。</span><br><span class="line"></span><br><span class="line">Build and run.  点击一个 item，我们就可以看到该行被勾号标记并排序。</span><br><span class="line"></span><br><span class="line">[![fb-toggle](http://upload-images.jianshu.io/upload_images/130752-9aac977cd7917893.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-toggle.gif)</span><br><span class="line">恭喜，我们已经完成了一个相当漂亮的 grocery list app 。</span><br><span class="line"></span><br><span class="line">#### Sorting the Grocery List</span><br><span class="line"></span><br><span class="line">如果把 ice cream 放在未排序的标记里面，有时我们可能会忘记它。现在让我们进行些优化。</span><br><span class="line"></span><br><span class="line">如果可以把已选中的 items 自动移动到列表底部，我们的 app 将更加令人喜欢。这样，未被标记的 items 可以更容易被我们发现。</span><br><span class="line"></span><br><span class="line">使用 [Firebase queries](https://firebase.google.com/docs/database/ios/retrieve-data#sorting_and_filtering_data), 我们可以根据任意属性对列表进行排序，在*GroceryListTableViewController.swift*, 更新 viewDidLoad() 方法：</span><br></pre></td></tr></table></figure></p>
<p>ref.queryOrdered(byChild: “completed”).observe(.value, with: { snapshot in<br>  var newItems: [GroceryItem] = []</p>
<p>  for item in snapshot.children {<br>    let groceryItem = GroceryItem(snapshot: item as! FIRDataSnapshot)<br>    newItems.append(groceryItem)<br>  }</p>
<p>  self.items = newItems<br>  self.tableView.reloadData()<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">通过关键词 “ completed”，使用 Firebase 引用 queryOrdered(byChild:) 对数据进行排序。</span><br><span class="line"></span><br><span class="line">由于列表需要完成顺序，所以 completed 键将传递给查询。然后，queryOrdered(byChild:)返回一个引用，通知服务器以有序的方式返回数据。</span><br><span class="line"></span><br><span class="line">Build and run. 点击一行，使其置换为已完成状态，我们将看到，它神奇地自动移动到了最后一行。</span><br><span class="line"></span><br><span class="line">[![fb-order](http://upload-images.jianshu.io/upload_images/130752-07b885c6c88401c3.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-order.gif)</span><br><span class="line"></span><br><span class="line">哇! 我们现在真的让购物变得更容易了。跨多个用户同步数据，似乎应该足够简单，例如，与一个重要的其他用户或 housemate。这听起来像…身份验证!</span><br><span class="line"></span><br><span class="line">#### Authenticating Users</span><br><span class="line"></span><br><span class="line">Firebase 有一个  [authentication service](https://firebase.google.com/docs/auth/)，它允许 apps 验证不同的提供者，我们可以使用  Google, Twitter, Facebook, Github, email &amp; password, 匿名, 甚至 custom backends 这些方式。这里我们使用邮箱和密码方式进行身份认证，因为这种方式是最简单的。</span><br><span class="line"></span><br><span class="line">进入 Firebase dashboard ，点击  *Auth*，激活邮箱密码认证。</span><br><span class="line"></span><br><span class="line">[![fb-auth-1](http://upload-images.jianshu.io/upload_images/130752-491d0ef2711afaf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-auth-1.png)</span><br><span class="line"></span><br><span class="line">选中 *SIGN-IN METHOD* 标签栏，再在 *Sign-in providers* 那一节选中*Email/Password* 行，切换 *Enable* 并点击 *SAVE*:</span><br><span class="line"></span><br><span class="line">[![authentication](http://upload-images.jianshu.io/upload_images/130752-d0ce6b1077067eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://koenig-media.raywenderlich.com/uploads/2016/07/authentication.png)</span><br><span class="line"></span><br><span class="line">Firebase 存储账户信息到 keychain，因此最后一步，在项目中，切换到 target’s Capabilities 打开 *Keychain Sharing* 开关。</span><br><span class="line"></span><br><span class="line">[![keychain-sharing](http://upload-images.jianshu.io/upload_images/130752-6d1bd69c54af152a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://koenig-media.raywenderlich.com/uploads/2016/07/keychain-sharing.png)</span><br><span class="line"></span><br><span class="line">现在，我们已经可以使用邮箱和密码进行身份认证了。</span><br><span class="line"></span><br><span class="line">##### Registering Users</span><br><span class="line"></span><br><span class="line">在 *LoginViewController.swift*，找到 signUpDidTouch(_:) 方法，这里会弹出 UIAlertController 让用户注册账号，定位到 saveAction 方法，添加以下代码到方法块儿。</span><br></pre></td></tr></table></figure></p>
<p>// 1<br>let emailField = alert.textFields![0]<br>let passwordField = alert.textFields![1] </p>
<p>// 2<br>FIRAuth.auth()!.createUser(withEmail: emailField.text!,<br>                           password: passwordField.text!) { user, error in<br>  if error == nil {<br>    // 3<br>    FIRAuth.auth()!.signIn(withEmail: self.textFieldLoginEmail.text!,<br>                           password: self.textFieldLoginPassword.text!)<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">以上代码解释:</span><br><span class="line">1. 从弹框中获取邮箱和密码。</span><br><span class="line">2. 调用 Firebase 方法 createUser(withEmail:password:)，传递邮箱和密码给它。</span><br><span class="line">3. 如果执行没有错误，用户账号即被创建。但是，我们还要再进行一下登录操作 signIn(withEmail:password:) ，同样需要传递邮箱和密码。</span><br><span class="line"></span><br><span class="line">Build and run.  点击 *Sign up* ，键入邮箱和密码，点击保存。现在 view controller 还不能在登录成功后导航到其它地方。我们刷新 Firebase *Login &amp; Auth* ，我们将看到新建的用户。</span><br><span class="line"></span><br><span class="line">[![fb-register-user](http://upload-images.jianshu.io/upload_images/130752-30037a7aab9db697.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-register-user.gif)</span><br><span class="line"></span><br><span class="line">喔！我们的 app 现在可以让用户注册并进行登录了，不过我们先不要庆祝，我们还需要再做些优化，好使用户更好的使用它。</span><br><span class="line"></span><br><span class="line">##### Logging Users In</span><br><span class="line"></span><br><span class="line">*Sign up*  按钮可以注册和登录，然而  *Login* 现在还什么都做不了，因为我们还没有给它绑定验证。</span><br><span class="line"></span><br><span class="line">到 *LoginViewController.swift*, 找到 loginDidTouch(_:) 方法，修改如下：</span><br></pre></td></tr></table></figure></p>
<p>@IBAction func loginDidTouch(_ sender: AnyObject) {<br>    FIRAuth.auth()!.signIn(withEmail: textFieldLoginEmail.text!,<br>                            password: textFieldLoginPassword.text!)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当用户点击 *Login* 时，这些代码将验证用户信息。</span><br><span class="line">我们接下来需要在用户登录成功后导航到下一个页面。</span><br><span class="line"></span><br><span class="line">##### Observing Authentication State</span><br><span class="line"></span><br><span class="line">Firebase 有可以监控用户验证状态的观察者。这里是添加 segue 最好的地方。在 *LoginViewController*: 添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>override func viewDidLoad() {<br>  super.viewDidLoad()      </p>
<p>  // 1<br>  FIRAuth.auth()!.addStateDidChangeListener() { auth, user in<br>    // 2<br>    if user != nil {<br>      // 3<br>      self.performSegue(withIdentifier: self.loginToList, sender: nil)<br>    }<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注释如下：</span><br><span class="line">1. 使用  addStateDidChangeListener(_:) 创建验证观察者。该 block 被传入两个参数：auth 和 user。</span><br><span class="line"></span><br><span class="line">2. 测试 user 的值，如果验证通过，返回用户信息，如果验证失败，返回 nil 。</span><br><span class="line"></span><br><span class="line">3. 验证成功，进行页面跳转。传输 sender 为 nil 。这看起来有些奇怪，但是稍后我们将在 *GroceryListTableViewController.swift* 进行设置。</span><br><span class="line"></span><br><span class="line">##### Setting the User in the Grocery List</span><br><span class="line">在 *GroceryListTableViewController.swift* 文件 viewDidLoad(): 方法底部添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>FIRAuth.auth()!.addStateDidChangeListener { auth, user in<br>  guard let user = user else { return }<br>  self.user = User(authData: user)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这里我们添加了一个 Firebase auth object 的验证观察者，当用户成功登录时，依次分配用户属性。</span><br><span class="line"></span><br><span class="line">Build and run. 如果用户已经登录，app 将跳过 LoginViewController 直接导航到 GroceryListTableViewController. 当用户添加 items ，他们的 email 将显示到 cell 的详情里面。</span><br><span class="line"></span><br><span class="line">[![fb-user-add](http://upload-images.jianshu.io/upload_images/130752-d600c0f675c1d508.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-user-add.gif)</span><br><span class="line"></span><br><span class="line">Success! app 现在已经有了基本的用户验证功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Monitoring Users’ Online Status</span><br><span class="line">现在既然我们的 app 已经拥有了用户验证功能，那是时候添加监控哪个用户在线功能了。打开 *GroceryListTableViewController.swift* ，添加如下 property:</span><br></pre></td></tr></table></figure></p>
<p>let usersRef = FIRDatabase.database().reference(withPath: “online”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是一个指向存储在线用户列表的在线位置的Firebase引用。</span><br><span class="line"></span><br><span class="line">下一步，在 viewDidLoad() 方法下添加如下代码到  addStateDidChangeListener(_:) 闭包的下面。</span><br></pre></td></tr></table></figure></p>
<p>// 1<br>let currentUserRef = self.usersRef.child(self.user.uid)<br>// 2<br>currentUserRef.setValue(self.user.email)<br>// 3<br>currentUserRef.onDisconnectRemoveValue()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">注释如下：</span><br><span class="line">1. 使用用户的 uid 创建一个 child 引用,当 Firebase 创建一个账号时，这个引用会被生成。</span><br><span class="line">2. 使用这个引用保存当前用户的 email.</span><br><span class="line">3. 当 Firebase 连接关闭的时候，例如用户退出 app , 调用 currentUserRef 的 onDisconnectRemoveValue()，删除位置引用的值。这可以完美监控离线用户。</span><br><span class="line"></span><br><span class="line">Build and run. 当 view 加载时，当前用户的电子邮件，会被添加在当前在线位置的一个子节点。</span><br><span class="line"></span><br><span class="line">[![fb-monitoring](http://upload-images.jianshu.io/upload_images/130752-b36f0c1581a54d0d.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-monitoring.gif)</span><br><span class="line"></span><br><span class="line">Great!  现在当用户数量增加时，是时候改变 bar button item 的个数了。</span><br><span class="line"></span><br><span class="line">##### Updating the Online User Count</span><br><span class="line"></span><br><span class="line">仍然在 *GroceryListTableViewController.swift* 的 viewDidLoad() 方法下添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>usersRef.observe(.value, with: { snapshot in<br>  if snapshot.exists() {<br>    self.userCountBarButtonItem?.title = snapshot.childrenCount.description<br>  } else {<br>    self.userCountBarButtonItem?.title = “0”<br>  }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这创建一个观察者监控在线用户，当用户在线或者离线，userCountBarButtonItem 的 title 随之更新。</span><br><span class="line"></span><br><span class="line">##### Displaying a List of Online Users</span><br><span class="line"></span><br><span class="line"> 打开 *OnlineUsersTableViewController.swift*，在 class 的 property section 添加一个本地引用到 Firebase 的在线用户记录。</span><br></pre></td></tr></table></figure></p>
<p>let usersRef = FIRDatabase.database().reference(withPath: “online”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，在viewDidLoad(), 替换代码</span><br></pre></td></tr></table></figure></p>
<p>currentUsers.append(“hungry@person.food”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为如下：</span><br></pre></td></tr></table></figure></p>
<p>// 1<br>usersRef.observe(.childAdded, with: { snap in<br>  // 2<br>  guard let email = snap.value as? String else { return }<br>  self.currentUsers.append(email)<br>  // 3<br>  let row = self.currentUsers.count - 1<br>  // 4<br>  let indexPath = IndexPath(row: row, section: 0)<br>  // 5<br>  self.tableView.insertRows(at: [indexPath], with: .top)<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">代码注释如下:</span><br><span class="line">1. 创建一个 children added 监听器，添加到被 usersRef 管理的位置。这与值侦听器不同，因为只有添加的 child 被传递到闭包。</span><br><span class="line"></span><br><span class="line">2. 从 snapshot 获取值，并赋值给本地变量 array。</span><br><span class="line">3. 因为 table view 的坐标从 0 开始计算，当前的 row 总是等于 array 的个数 -1。</span><br><span class="line">4. 使用当前 row index 创建一个 NSIndexPath.</span><br><span class="line"></span><br><span class="line">5. 使用动画从顶部添加一行到 table view.</span><br><span class="line"></span><br><span class="line">这将只渲染添加的条目，而不是重新加载整个列表，而且还可以指定一个漂亮的动画。:]</span><br><span class="line"></span><br><span class="line">由于用户可以脱机，table 需要对被删除的用户做出反应。在我们刚刚添加的代码下面添加以下内容：</span><br></pre></td></tr></table></figure></p>
<p>usersRef.observe(.childRemoved, with: { snap in<br>  guard let emailToFind = snap.value as? String else { return }<br>  for (index, email) in self.currentUsers.enumerated() {<br>    if email == emailToFind {<br>      let indexPath = IndexPath(row: index, section: 0)<br>      self.currentUsers.remove(at: index)<br>      self.tableView.deleteRows(at: [indexPath], with: .fade)<br>    }<br>  }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这只是添加了一个观察者，它侦听被删除的 usersRef 引用的子元素。它在本地数组中搜索电子邮件的值，以找到相应的子条目，一旦找到，它就从表中删除相关的行。</span><br><span class="line"></span><br><span class="line">Build and run.</span><br><span class="line"></span><br><span class="line">在 Firebase 用户仪表板上点击 *Online *，当前用户的电子邮件将出现在表格中。使用一些技巧，可以在网上添加一个用户，一旦你做了，它就会显示在列表中。在仪表板上单击*删除*按钮，用户就会从 table 中消失….</span><br><span class="line"></span><br><span class="line">[![fb-users-table](http://upload-images.jianshu.io/upload_images/130752-8c79b48329764b6c.gif?imageMogr2/auto-orient/strip)](https://koenig-media.raywenderlich.com/uploads/2016/07/fb-users-table.gif)</span><br><span class="line"></span><br><span class="line">Booyah!  当用户被添加和删除的时候，table 随之更新了。</span><br><span class="line"></span><br><span class="line">[![monintoring-users](http://upload-images.jianshu.io/upload_images/130752-c8da3f05b344b399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://koenig-media.raywenderlich.com/uploads/2015/07/monintoring-users.png)</span><br><span class="line"></span><br><span class="line">##### Enabling Offline</span><br><span class="line"></span><br><span class="line">杂货店因不稳定的数据连接而臭名昭著。你会认为他们现在都有了Wi-Fi，但是没有!</span><br><span class="line"></span><br><span class="line">不过没关系，我们只需设置数据库离线工作。打开 * AppDelegate*,在(_:didFinishLaunchingWithOptions:) 底部方法返回 true 之前，添加如下代码：</span><br></pre></td></tr></table></figure></p>
<p>FIRDatabase.database().persistenceEnabled = true<br>```</p>
<p>是的,就是这样! 就像我们的应用能够离线运行一样。当 app 重启，一旦建立网络连接，离线更新也将作用于我们的 Firebase 数据库。Oooh-ahhhh !</p>
<h5 id="Where-To-Go-From-Here"><a href="#Where-To-Go-From-Here" class="headerlink" title="Where To Go From Here?"></a>Where To Go From Here?</h5><p>我们可以在<a href="https://koenig-media.raywenderlich.com/uploads/2016/09/Grocr-final.zip" target="_blank" rel="external">这里下载 Grocr-final</a>完整项目。</p>
<blockquote>
<p>注意：下载完后，我们仍需要添加自己的 <em>GoogleService-Info.plist</em> 和 设置允许<em>Keychain sharing</em> 。</p>
</blockquote>
<p>在这个Firebase教程中，我们通过构建一个协作的购物清单 app 了解了Firebase的基础知识，我们已经实现了将数据保存到一个 Firebase 数据库、实时同步数据、认证用户、监视在线用户状态以及实现了离线支持。所有这些都是在没有写一行服务器代码的情况下完成的!  :]</p>
<p>如果你对 Firebase 感兴趣，请查看文档 <a href="https://firebase.google.com/docs/" target="_blank" rel="external">documentation</a>，以及 Firebase 提供的示例。</p>
<p>如果您对这个Firebase教程、Firebase或示例应用有任何意见或问题，请加入下面的论坛讨论!</p>
<pre><code>2017.09.06 19:02
       上海 虹桥V1 
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Joey Chang" />
          <p class="site-author-name" itemprop="name">Joey Chang</p>
          <p class="site-description motion-element" itemprop="description">读书、写字、周游天下...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">57</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/iJoeychang" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/9a969b4dae83/latest_articles" target="_blank">
                  
                    <i class="fa fa-home"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3490688707" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joey Chang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>位到访者



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"joeychang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  


  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>



</body>
</html>
